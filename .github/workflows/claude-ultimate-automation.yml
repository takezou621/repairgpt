name: Claude Ultimate Automation

on:
  # schedule:
  #   - cron: '*/1 * * * *'  # ÊØéÂàÜÂÆüË°å - ÁÑ°ÂäπÂåñ
  workflow_dispatch:  # ÊâãÂãïÂÆüË°å„ÅÆ„Åø
  # push:
  #   branches: ['claude/**']  # ÁÑ°ÂäπÂåñ

jobs:
  ultimate-automation:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
      actions: read
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
        ref: main
    
    - name: Ultimate Issue Processing
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          console.log('üöÄ ULTIMATE AUTOMATION START');
          
          try {
            // ÂÖ®„Ç™„Éº„Éó„É≥Issue„ÇíÂèñÂæó
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100
            });
            
            console.log(`Found ${issues.data.length} open issues`);
            
            // claude-processed„É©„Éô„É´„Åå„ÅÇ„ÇãIssue„ÇíÊ§úÁ¥¢
            const processedIssues = issues.data.filter(issue => 
              issue.labels.some(label => label.name === 'claude-processed')
            );
            
            console.log(`Found ${processedIssues.length} Claude-processed issues`);
            
            for (const issue of processedIssues) {
              console.log(`\nüîç Processing Issue #${issue.number}: ${issue.title}`);
              
              // Èñ¢ÈÄ£„Éñ„É©„É≥„ÉÅ„ÇíÊ§úÁ¥¢
              const branches = await github.rest.repos.listBranches({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              });
              
              const claudeBranch = branches.data.find(branch => 
                branch.name.includes(`issue-${issue.number}`) ||
                branch.name.includes(`${issue.number}`)
              );
              
              if (!claudeBranch) {
                console.log(`No branch found for Issue #${issue.number}`);
                continue;
              }
              
              console.log(`Found branch: ${claudeBranch.name}`);
              
              // Êó¢Â≠òPR„Çí„ÉÅ„Çß„ÉÉ„ÇØ
              const existingPRs = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head: `${context.repo.owner}:${claudeBranch.name}`,
                state: 'all'
              });
              
              if (existingPRs.data.length > 0) {
                const pr = existingPRs.data[0];
                console.log(`Found existing PR #${pr.number}, state: ${pr.state}`);
                
                if (pr.state === 'open') {
                  // „Ç™„Éº„Éó„É≥PR„ÇíËá™Âãï„Éû„Éº„Ç∏
                  console.log(`üîÑ Auto-merging PR #${pr.number}`);
                  
                  try {
                    await github.rest.pulls.merge({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: pr.number,
                      commit_title: `Ultimate Auto-merge: Issue #${issue.number}`,
                      merge_method: 'squash'
                    });
                    console.log(`‚úÖ Merged PR #${pr.number}`);
                  } catch (mergeError) {
                    console.log(`‚ö†Ô∏è Merge failed: ${mergeError.message}`);
                    continue;
                  }
                }
              } else {
                // PR„Çí‰ΩúÊàê
                console.log(`üìù Creating PR for Issue #${issue.number}`);
                
                try {
                  const pr = await github.rest.pulls.create({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    title: `fix: ${issue.title} (closes #${issue.number})`,
                    head: claudeBranch.name,
                    base: 'main',
                    body: `## ü§ñ Á©∂Ê•µÂÆåÂÖ®Ëá™ÂãïÂåñ
          
          ### Èñ¢ÈÄ£Issue
          Closes #${issue.number}
          
          ### Ëá™ÂãïÂåñ„Éï„É≠„Éº
          - [x] ‚úÖ Claude CodeÂÆüË£ÖÂÆå‰∫Ü
          - [x] ‚úÖ Ëá™ÂãïPR‰ΩúÊàê
          - [x] ‚úÖ Âç≥Â∫ß„Å´Ëá™Âãï„Éû„Éº„Ç∏
          - [x] ‚úÖ IssueËá™Âãï„ÇØ„É≠„Éº„Ç∫
          - [x] ‚úÖ „Éñ„É©„É≥„ÉÅËá™ÂãïÂâäÈô§
          
          ---
          üöÄ **Á©∂Ê•µ„ÅÆ100%ÂÆåÂÖ®Ëá™ÂãïÂåñ** | Generated with Claude Code Max`
                  });
                  
                  console.log(`‚úÖ Created PR #${pr.data.number}`);
                  
                  // Âç≥Â∫ß„Å´„Éû„Éº„Ç∏
                  await new Promise(resolve => setTimeout(resolve, 2000));
                  
                  await github.rest.pulls.merge({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: pr.data.number,
                    commit_title: `Ultimate Auto-merge: Issue #${issue.number}`,
                    merge_method: 'squash'
                  });
                  
                  console.log(`‚úÖ Auto-merged PR #${pr.data.number}`);
                  
                } catch (prError) {
                  console.log(`‚ùå PR creation/merge failed: ${prError.message}`);
                  continue;
                }
              }
              
              // IssueÂÆå‰∫ÜÂá¶ÁêÜ
              console.log(`üîí Closing Issue #${issue.number}`);
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `üéâ **Á©∂Ê•µÂÆåÂÖ®Ëá™ÂãïÂåñ„Éï„É≠„ÉºÂÆüË°åÂÆå‰∫Ü**
          
          Issue #${issue.number} „ÅÆÂá¶ÁêÜ„Åå100%Ëá™Âãï„ÅßÂÆå‰∫Ü„Åó„Åæ„Åó„Åü„ÄÇ
          
          **ÂÆüË°åÂÜÖÂÆπ:**
          - ü§ñ Claude Code MaxÂÆüË£ÖÊ§úÁü•
          - üìù Ëá™ÂãïPR‰ΩúÊàê„Éª„Éû„Éº„Ç∏
          - üîí IssueËá™Âãï„ÇØ„É≠„Éº„Ç∫
          - üßπ „Éñ„É©„É≥„ÉÅËá™ÂãïÂâäÈô§
          
          **ÂÆüË°åÊôÇÂàª:** $(date)
          
          ---
          üöÄ **Áúü„ÅÆ100%ÂÆåÂÖ®Ëá™ÂãïÂåñÈÅîÊàê** | Ultimate Automation`
              });
              
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                state: 'closed'
              });
              
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: ['claude-completed', 'ultimate-automation']
              });
              
              // „Éñ„É©„É≥„ÉÅÂâäÈô§
              await new Promise(resolve => setTimeout(resolve, 3000));
              
              try {
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `heads/${claudeBranch.name}`
                });
                console.log(`üóëÔ∏è Deleted branch ${claudeBranch.name}`);
              } catch (deleteError) {
                console.log(`‚ö†Ô∏è Branch deletion failed: ${deleteError.message}`);
              }
              
              console.log(`üéØ Issue #${issue.number} ULTIMATE AUTOMATION COMPLETED!`);
            }
            
            console.log('\nüöÄ ULTIMATE AUTOMATION FINISHED');
            
          } catch (error) {
            console.log(`‚ùå Ultimate automation error: ${error.message}`);
            console.log(error.stack);
          }