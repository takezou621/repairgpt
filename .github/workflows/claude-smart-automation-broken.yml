name: Claude Smart Automation Fixed

on:
  schedule:
    # å¹³æ—¥: 23:00, 02:00, 05:00 JST (14:00, 17:00, 20:00 UTC)
    - cron: '0 14,17,20 * * 1-5'
    # åœŸæ—¥: 10:00, 14:00, 18:00, 22:00 JST (01:00, 05:00, 09:00, 13:00 UTC)
    - cron: '0 1,5,9,13 * * 0,6'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Enable dry run mode (true/false)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

jobs:
  smart-automation:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
      actions: read
    
    env:
      DRY_RUN: ${{ github.event.inputs.dry_run || 'false' }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Execute Smart Automation
      uses: actions/github-script@v7
      with:
        script: |
          const now = new Date();
          const day = now.getUTCDay();
          const hour = now.getUTCHours();
          const isWeekend = day === 0 || day === 6;
          const isDryRun = process.env.DRY_RUN === 'true';
          
          console.log('ğŸ¤– Claude Smart Automation Fixed - Started');
          console.log(`Current time: ${now.toISOString()}`);
          console.log(`Day: ${day}, Hour: ${hour}UTC, Weekend: ${isWeekend}`);
          console.log(`Dry Run Mode: ${isDryRun}`);
          
          // APIãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒã‚§ãƒƒã‚¯
          async function checkRateLimit() {
            const rateLimit = await github.rest.rateLimit.get();
            const remaining = rateLimit.data.rate.remaining;
            console.log(`ğŸ“Š API Rate Limit: ${remaining} remaining`);
            
            if (remaining < 100) {
              console.log('â³ API rate limit low. Exiting to preserve quota.');
              return false;
            }
            return true;
          }
          
          if (!await checkRateLimit()) {
            return;
          }
          
          // Issueæ¤œç´¢
          const issues = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            labels: 'claude-processed',
            state: 'open',
            per_page: 10
          });
          
          console.log(`ğŸ“‹ Found ${issues.data.length} issues with claude-processed label`);
          
          let processedCount = 0;
          let autoImplementedCount = 0;
          
          for (const issue of issues.data) {
            console.log(`\\nğŸ” Processing Issue #${issue.number}: ${issue.title}`);
            
            // é‡è¤‡å‡¦ç†é˜²æ­¢
            const hasProcessingLabel = issue.labels.some(label => label.name === 'claude-processing');
            if (hasProcessingLabel) {
              console.log(`âš ï¸ Issue #${issue.number} is already being processed. Skipping...`);
              continue;
            }
            
            try {
              // å‡¦ç†é–‹å§‹ãƒ©ãƒ™ãƒ«è¿½åŠ 
              if (!isDryRun) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['claude-processing']
                });
              }
              
              // ãƒ–ãƒ©ãƒ³ãƒæ¤œç´¢
              const branches = await github.rest.repos.listBranches({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              });
              
              const issueNum = issue.number.toString();
              const matchingBranches = branches.data.filter(branch => {
                const branchLower = branch.name.toLowerCase();
                return (
                  branchLower.includes(\`issue-\${issueNum}\`) ||
                  (branchLower.includes('claude') && branchLower.includes(issueNum)) ||
                  branchLower.includes(\`fix-\${issueNum}\`) ||
                  branchLower.includes(\`feature-\${issueNum}\`)
                );
              });
              
              if (matchingBranches.length === 0) {
                console.log(`âš ï¸ No branch found for Issue #${issue.number} - Starting auto-implementation`);
                
                // è‡ªå‹•å®Ÿè£…é–‹å§‹
                const newBranchName = \`claude-auto-impl-issue-\${issue.number}\`;
                
                try {
                  // æ–°ãƒ–ãƒ©ãƒ³ãƒä½œæˆ
                  const mainBranch = await github.rest.repos.getBranch({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    branch: 'main'
                  });
                  
                  if (!isDryRun) {
                    await github.rest.git.createRef({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      ref: \`refs/heads/\${newBranchName}\`,
                      sha: mainBranch.data.commit.sha
                    });
                  }
                  
                  console.log(\`âœ… Created branch: \${newBranchName}\`);
                  
                  // Issueåˆ†æã¨å®Ÿè£…ã‚¿ã‚¤ãƒ—åˆ¤å®š
                  const issueBody = issue.body || '';
                  const issueTitle = issue.title || '';
                  const combinedText = \`\${issueTitle}\\n\\n\${issueBody}\`;
                  
                  let implementationType = 'documentation';
                  let targetFile = \`docs/auto-generated/issue-\${issue.number}.md\`;
                  
                  if (combinedText.match(/ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼|workflow|github.*action/i)) {
                    implementationType = 'workflow';
                    targetFile = 'docs/workflow-improvements.md';
                  } else if (combinedText.match(/æ©Ÿèƒ½.*è¿½åŠ |feature.*add|å®Ÿè£…|implement/i)) {
                    implementationType = 'feature';
                    targetFile = \`src/auto_feature_\${issue.number}.py\`;
                  } else if (combinedText.match(/ãƒã‚°|bug|ä¿®æ­£|fix|ã‚¨ãƒ©ãƒ¼|error/i)) {
                    implementationType = 'bugfix';
                    targetFile = \`src/bugfix_\${issue.number}.py\`;
                  }
                  
                  // å®Ÿè£…å†…å®¹ç”Ÿæˆ
                  const implementationContent = generateImplementationContent(
                    issue.number, 
                    issueTitle, 
                    issueBody, 
                    implementationType
                  );
                  
                  // ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ
                  if (!isDryRun) {
                    const encodedContent = Buffer.from(implementationContent).toString('base64');
                    
                    await github.rest.repos.createOrUpdateFileContents({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      path: targetFile,
                      message: \`Auto-implementation: \${implementationType} for Issue #\${issue.number}\`,
                      content: encodedContent,
                      branch: newBranchName
                    });
                  }
                  
                  console.log(\`ğŸ“ Created file: \${targetFile}\`);
                  
                  // è‡ªå‹•å®Ÿè£…ã‚³ãƒ¡ãƒ³ãƒˆ
                  const commentBody = [
                    'ğŸš€ **æœªç€æ‰‹Issueè‡ªå‹•å®Ÿè£…é–‹å§‹ï¼**',
                    '',
                    \`âœ… **æ–°ãƒ–ãƒ©ãƒ³ãƒ**: \\\`\${newBranchName}\\\`\`,
                    \`ğŸ¤– **å®Ÿè£…ã‚¿ã‚¤ãƒ—**: \${implementationType}\`,
                    \`ğŸ“ **å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«**: \${targetFile}\`,
                    '',
                    '**æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—:**',
                    '- ğŸ”„ PRè‡ªå‹•ä½œæˆäºˆå®š',
                    '- ğŸ“Š åŸºæœ¬å®Ÿè£…ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”Ÿæˆæ¸ˆã¿',
                    '',
                    '---',
                    'ğŸ¤– **Claude Smart Automation** - æœªç€æ‰‹Issueè‡ªå‹•å®Ÿè£…'
                  ].join('\\n');
                  
                  if (!isDryRun) {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      body: commentBody
                    });
                  }
                  
                  autoImplementedCount++;
                  console.log(\`ğŸ‰ Auto-implementation completed for Issue #\${issue.number}\`);
                  
                } catch (autoError) {
                  console.log(\`âŒ Auto-implementation failed: \${autoError.message}\`);
                  
                  if (!isDryRun) {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      body: \`âŒ **è‡ªå‹•å®Ÿè£…ã‚¨ãƒ©ãƒ¼**\\n\\nã‚¨ãƒ©ãƒ¼: \${autoError.message}\\n\\næ‰‹å‹•å¯¾å¿œã‚’ãŠé¡˜ã„ã—ã¾ã™ã€‚\`
                    });
                  }
                }
              } else {
                console.log(\`âœ… Found \${matchingBranches.length} branch(es) for Issue #\${issue.number}\`);
                
                // æ—¢å­˜ãƒ–ãƒ©ãƒ³ãƒãŒã‚ã‚‹å ´åˆã®PRå‡¦ç†ï¼ˆç°¡ç•¥ç‰ˆï¼‰
                const targetBranch = matchingBranches[0];
                
                // æ—¢å­˜PRç¢ºèª
                const existingPRs = await github.rest.pulls.list({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  head: \`\${context.repo.owner}:\${targetBranch.name}\`,
                  state: 'open'
                });
                
                if (existingPRs.data.length === 0) {
                  console.log(\`ğŸš€ Creating PR for Issue #\${issue.number}...\`);
                  
                  const timeContext = isWeekend ? 'åœŸæ—¥æ˜¼é–“' : 'å¹³æ—¥å¤œé–“';
                  
                  if (!isDryRun) {
                    const pr = await github.rest.pulls.create({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      title: \`fix: \${issue.title} (closes #\${issue.number})\`,
                      head: targetBranch.name,
                      base: 'main',
                      body: [
                        \`## ğŸ¤– \${timeContext}ã‚¹ãƒãƒ¼ãƒˆè‡ªå‹•åŒ–\`,
                        '',
                        \`**Issue**: #\${issue.number}\`,
                        \`**ãƒ–ãƒ©ãƒ³ãƒ**: \${targetBranch.name}\`,
                        \`**å®Ÿè¡Œæ™‚åˆ»**: \${now.toISOString()}\`,
                        '',
                        '### ğŸ“‹ å¤‰æ›´å†…å®¹',
                        \`\${issue.title}ã®å®Ÿè£…ãƒ»ä¿®æ­£\`,
                        '',
                        '---',
                        'ğŸš€ Generated with [Claude Code](https://claude.ai/code)',
                        '',
                        'Co-Authored-By: Claude <noreply@anthropic.com>'
                      ].join('\\n')
                    });
                    
                    console.log(\`âœ… Created PR #\${pr.data.number}\`);
                  }
                } else {
                  console.log(\`â„¹ï¸ PR already exists for Issue #\${issue.number}\`);
                }
              }
              
              // å‡¦ç†å®Œäº†å¾Œã®ãƒ©ãƒ™ãƒ«æ›´æ–°
              if (!isDryRun) {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  name: 'claude-processing'
                }).catch(() => {}); // ãƒ©ãƒ™ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ç„¡è¦–
              }
              
              processedCount++;
              
            } catch (error) {
              console.log(\`âŒ Error processing Issue #\${issue.number}: \${error.message}\`);
            }
          }
          
          // å®Ÿè¡Œçµ±è¨ˆ
          const timeContext = isWeekend ? 'åœŸæ—¥æ˜¼é–“' : 'å¹³æ—¥å¤œé–“';
          console.log(\`\\nğŸ“Š **å®Ÿè¡Œå®Œäº†çµ±è¨ˆ** - \${timeContext}è‡ªå‹•å®Ÿè¡Œ\`);
          console.log(\`- å‡¦ç†å¯¾è±¡Issues: \${issues.data.length}å€‹\`);
          console.log(\`- å‡¦ç†å®Œäº†: \${processedCount}å€‹\`);
          console.log(\`- è‡ªå‹•å®Ÿè£…é–‹å§‹: \${autoImplementedCount}å€‹\`);
          console.log(\`- å®Ÿè¡Œãƒ¢ãƒ¼ãƒ‰: \${isDryRun ? 'ãƒ‰ãƒ©ã‚¤ãƒ©ãƒ³' : 'æœ¬ç•ªå®Ÿè¡Œ'}\`);
          
          // å®Ÿè£…å†…å®¹ç”Ÿæˆãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
          function generateImplementationContent(issueNumber, title, body, type) {
            const timestamp = new Date().toISOString();
            
            if (type === 'feature') {
              return \`# Auto-Generated Feature Implementation
# Issue #\${issueNumber}: \${title}

def auto_feature_\${issueNumber}():
    """
    Auto-generated feature implementation for Issue #\${issueNumber}
    
    Title: \${title}
    Generated: \${timestamp}
    """
    print(f"Feature implementation for Issue #\${issueNumber}")
    
    # TODO: Add specific implementation
    return {
        'status': 'auto_implemented',
        'issue_number': \${issueNumber},
        'type': '\${type}'
    }

if __name__ == "__main__":
    result = auto_feature_\${issueNumber}()
    print(f"Result: {result}")
\`;
            } else if (type === 'bugfix') {
              return \`# Auto-Generated Bug Fix
# Issue #\${issueNumber}: \${title}

def auto_bugfix_\${issueNumber}():
    """
    Auto-generated bug fix for Issue #\${issueNumber}
    
    Title: \${title}
    Generated: \${timestamp}
    """
    print(f"Bug fix for Issue #\${issueNumber}")
    
    try:
        # TODO: Add specific bug fix implementation
        pass
    except Exception as e:
        print(f"Error in bug fix: {e}")
        return False
    
    return True

if __name__ == "__main__":
    success = auto_bugfix_\${issueNumber}()
    print(f"Bug fix {'successful' if success else 'failed'}")
\`;
            } else {
              return \`# \${title}

## Issue #\${issueNumber} è‡ªå‹•å¯¾å¿œ

ã“ã®æ–‡æ›¸ã¯ **Claude Smart Automation** ã«ã‚ˆã‚Šè‡ªå‹•ç”Ÿæˆã•ã‚Œã¾ã—ãŸã€‚

### ğŸ“‹ Issueæ¦‚è¦
- **Issueç•ªå·**: #\${issueNumber}
- **ã‚¿ã‚¤ãƒˆãƒ«**: \${title}
- **å®Ÿè£…ã‚¿ã‚¤ãƒ—**: \${type}
- **è‡ªå‹•ç”Ÿæˆæ—¥æ™‚**: \${timestamp}

### ğŸ¤– è‡ªå‹•å®Ÿè£…å†…å®¹

\${body ? '**Issueè©³ç´°:**\\n' + body + '\\n' : ''}

### âœ… å®Ÿè£…é …ç›®
- [x] Issueå†…å®¹ã®è‡ªå‹•åˆ†æ
- [x] åŸºæœ¬å®Ÿè£…ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”Ÿæˆ
- [x] è‡ªå‹•ãƒ–ãƒ©ãƒ³ãƒä½œæˆ
- [ ] è©³ç´°å®Ÿè£…ï¼ˆæ‰‹å‹•èª¿æ•´å¿…è¦ï¼‰

### ğŸ”„ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—
1. ç”Ÿæˆã•ã‚ŒãŸå®Ÿè£…å†…å®¹ã‚’ç¢ºèª
2. å¿…è¦ã«å¿œã˜ã¦è©³ç´°ã‚’è¿½åŠ 
3. ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã®ä½œæˆ
4. æœ€çµ‚å‹•ä½œç¢ºèª

---
ğŸš€ **Claude Smart Automation** - æœªç€æ‰‹Issueè‡ªå‹•å®Ÿè£…ã‚·ã‚¹ãƒ†ãƒ 

Generated with [Claude Code](https://claude.ai/code)
\`;
            }
          }
