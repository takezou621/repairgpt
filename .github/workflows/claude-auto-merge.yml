name: Claude Auto PR and Merge

on:
  issue_comment:
    types: [created, edited]
  workflow_run:
    workflows: ["Claude Code"]
    types: [completed]

jobs:
  auto-pr-and-merge:
    # ClaudeãŒä½œæ¥­å®Œäº†ã‚’å ±å‘Šã—ãŸå ´åˆã®ã¿å®Ÿè¡Œ
    if: |
      (github.event_name == 'issue_comment' && 
       github.event.comment.user.login == 'claude' &&
       (contains(github.event.comment.body, 'ä½œæ¥­ãŒå®Œäº†') || 
        contains(github.event.comment.body, 'finished') ||
        contains(github.event.comment.body, 'Task completed') ||
        contains(github.event.comment.body, 'Implementation complete'))) ||
      (github.event_name == 'workflow_run' &&
       github.event.workflow_run.conclusion == 'success')
    
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
      actions: read
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Get issue and branch information
      id: issue-info
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          let issueNumber, issueTitle, issueBody;
          
          if (context.eventName === 'issue_comment') {
            // ã‚³ãƒ¡ãƒ³ãƒˆã‚¤ãƒ™ãƒ³ãƒˆã®å ´åˆ
            issueNumber = context.issue.number;
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            issueTitle = issue.data.title;
            issueBody = issue.data.body;
          } else if (context.eventName === 'workflow_run') {
            // ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œå®Œäº†ã®å ´åˆã€é–¢é€£ã™ã‚‹issueã‚’æ¤œç´¢
            const runs = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'claude-code.yml',
              status: 'completed',
              per_page: 1
            });
            
            if (runs.data.workflow_runs.length === 0) {
              console.log('No completed workflow runs found');
              return {};
            }
            
            // æœ€æ–°ã®å®Œäº†ã—ãŸãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã«é–¢é€£ã™ã‚‹issueã‚’ç‰¹å®š
            const latestRun = runs.data.workflow_runs[0];
            const issueMatch = latestRun.display_title.match(/#(\d+)/);
            
            if (!issueMatch) {
              console.log('No issue number found in workflow title');
              return {};
            }
            
            issueNumber = parseInt(issueMatch[1]);
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            issueTitle = issue.data.title;
            issueBody = issue.data.body;
          }
          
          const branchName = `fix/issue-${issueNumber}`;
          const prTitle = `fix: ${issueTitle} (closes #${issueNumber})`;
          
          return {
            issueNumber,
            issueTitle,
            issueBody,
            branchName,
            prTitle
          };
    
    - name: Check if branch exists and create PR
      id: create-pr
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const issueInfo = ${{ steps.issue-info.outputs.result }};
          
          if (!issueInfo.issueNumber) {
            console.log('No issue information found, skipping PR creation');
            return { created: false };
          }
          
          // ãƒ–ãƒ©ãƒ³ãƒãŒå­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
          let branchExists = false;
          try {
            await github.rest.repos.getBranch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              branch: issueInfo.branchName
            });
            branchExists = true;
          } catch (error) {
            if (error.status !== 404) {
              throw error;
            }
          }
          
          if (!branchExists) {
            console.log(`Branch ${issueInfo.branchName} does not exist, skipping PR creation`);
            return { created: false, issueNumber: issueInfo.issueNumber };
          }
          
          // æ—¢å­˜ã®PRã‚’ãƒã‚§ãƒƒã‚¯
          const existingPRs = await github.rest.pulls.list({
            owner: context.repo.owner,
            repo: context.repo.repo,
            head: `${context.repo.owner}:${issueInfo.branchName}`,
            state: 'open'
          });
          
          if (existingPRs.data.length > 0) {
            console.log('PR already exists for this branch');
            return { 
              created: false, 
              prNumber: existingPRs.data[0].number,
              issueNumber: issueInfo.issueNumber 
            };
          }
          
          // PRã‚’ä½œæˆ
          const prBody = `## æ¦‚è¦
ã“ã®PRã¯Claude Code Maxã«ã‚ˆã£ã¦è‡ªå‹•å®Ÿè£…ã•ã‚ŒãŸissue #${issueInfo.issueNumber}ã®è§£æ±ºã§ã™ã€‚

## é–¢é€£Issue
Closes #${issueInfo.issueNumber}

## å¤‰æ›´å†…å®¹
ClaudeãŒå®Ÿè£…ã—ãŸå¤‰æ›´å†…å®¹ï¼š
- Issue "${issueInfo.issueTitle}" ã¸ã®å¯¾å¿œ

## ãƒ†ã‚¹ãƒˆ
- [ ] å‹•ä½œç¢ºèªæ¸ˆã¿
- [ ] æ—¢å­˜æ©Ÿèƒ½ã¸ã®å½±éŸ¿ãªã—

---
ðŸ¤– è‡ªå‹•ç”Ÿæˆã•ã‚ŒãŸPR (Claude Code Max)`;
          
          const pr = await github.rest.pulls.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: issueInfo.prTitle,
            head: issueInfo.branchName,
            base: 'main',
            body: prBody
          });
          
          console.log(`Created PR #${pr.data.number}`);
          
          return {
            created: true,
            prNumber: pr.data.number,
            issueNumber: issueInfo.issueNumber
          };
    
    - name: Auto-review and merge PR
      if: steps.create-pr.outputs.result && fromJSON(steps.create-pr.outputs.result).created
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const result = ${{ steps.create-pr.outputs.result }};
          
          if (!result.created) {
            console.log('No PR was created, skipping auto-merge');
            return;
          }
          
          const prNumber = result.prNumber;
          
          // PRã«è‡ªå‹•ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ©ãƒ™ãƒ«ã‚’è¿½åŠ 
          await github.rest.issues.addLabels({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: prNumber,
            labels: ['claude-auto-generated', 'ready-for-merge']
          });
          
          // å°‘ã—å¾…ã£ã¦ã‹ã‚‰ãƒžãƒ¼ã‚¸ï¼ˆCI/CDãŒã‚ã‚‹å ´åˆã®æ™‚é–“ç¢ºä¿ï¼‰
          await new Promise(resolve => setTimeout(resolve, 10000));
          
          try {
            // PRã‚’ãƒžãƒ¼ã‚¸
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              commit_title: `Auto-merge: Claude Code implementation for issue #${result.issueNumber}`,
              commit_message: `Automatically merged PR created by Claude Code Max for issue #${result.issueNumber}`,
              merge_method: 'squash'
            });
            
            console.log(`Successfully merged PR #${prNumber}`);
            
            // ãƒžãƒ¼ã‚¸å®Œäº†ã‚³ãƒ¡ãƒ³ãƒˆã‚’Issueã«è¿½åŠ 
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: result.issueNumber,
              body: `âœ… **è‡ªå‹•ãƒžãƒ¼ã‚¸å®Œäº†**

PR #${prNumber} ãŒæ­£å¸¸ã«ãƒžãƒ¼ã‚¸ã•ã‚Œã¾ã—ãŸã€‚
Claude Code Maxã«ã‚ˆã‚‹å®Ÿè£…ãŒæœ¬ç•ªãƒ–ãƒ©ãƒ³ãƒã«åæ˜ ã•ã‚Œã¾ã—ãŸã€‚

ðŸ¤– è‡ªå‹•åŒ–ãƒ•ãƒ­ãƒ¼å®Œäº†`
            });
            
          } catch (error) {
            console.log(`Failed to merge PR #${prNumber}: ${error.message}`);
            
            // ãƒžãƒ¼ã‚¸å¤±æ•—ã‚’Issueã«å ±å‘Š
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: result.issueNumber,
              body: `âš ï¸ **è‡ªå‹•ãƒžãƒ¼ã‚¸ã«å¤±æ•—ã—ã¾ã—ãŸ**

PR #${prNumber} ã®è‡ªå‹•ãƒžãƒ¼ã‚¸ã«å¤±æ•—ã—ã¾ã—ãŸã€‚
æ‰‹å‹•ã§ã®ãƒ¬ãƒ“ãƒ¥ãƒ¼ã¨ãƒžãƒ¼ã‚¸ãŒå¿…è¦ã§ã™ã€‚

ã‚¨ãƒ©ãƒ¼: ${error.message}`
            });
          }
    
    - name: Close issue and cleanup
      if: steps.create-pr.outputs.result
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const result = ${{ steps.create-pr.outputs.result }};
          const issueNumber = result.issueNumber;
          
          if (!issueNumber) {
            console.log('No issue number found, skipping cleanup');
            return;
          }
          
          // PRãŒæ­£å¸¸ã«ãƒžãƒ¼ã‚¸ã•ã‚ŒãŸå ´åˆã€Issueã‚’ã‚¯ãƒ­ãƒ¼ã‚º
          if (result.created) {
            try {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                state: 'closed'
              });
              
              console.log(`Closed issue #${issueNumber}`);
              
              // å®Œäº†ãƒ©ãƒ™ãƒ«ã‚’è¿½åŠ 
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                labels: ['claude-completed']
              });
              
            } catch (error) {
              console.log(`Failed to close issue #${issueNumber}: ${error.message}`);
            }
          }
    
    - name: Delete feature branch
      if: steps.create-pr.outputs.result && fromJSON(steps.create-pr.outputs.result).created
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const result = ${{ steps.create-pr.outputs.result }};
          
          if (!result.created) {
            console.log('No PR was created, skipping branch deletion');
            return;
          }
          
          const branchName = `fix/issue-${result.issueNumber}`;
          
          try {
            // å°‘ã—å¾…ã£ã¦ã‹ã‚‰ãƒ–ãƒ©ãƒ³ãƒã‚’å‰Šé™¤ï¼ˆãƒžãƒ¼ã‚¸å®Œäº†å¾Œã®æ™‚é–“ç¢ºä¿ï¼‰
            await new Promise(resolve => setTimeout(resolve, 5000));
            
            await github.rest.git.deleteRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: `heads/${branchName}`
            });
            
            console.log(`Deleted branch ${branchName}`);
            
          } catch (error) {
            console.log(`Failed to delete branch ${branchName}: ${error.message}`);
          }