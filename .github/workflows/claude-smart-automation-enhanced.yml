name: Claude Smart Automation Enhanced

on:
  schedule:
    # å¹³æ—¥: 23:00, 02:00, 05:00 JST (14:00, 17:00, 20:00 UTC)
    - cron: '0 14,17,20 * * 1-5'
    # åœŸæ—¥: 10:00, 14:00, 18:00, 22:00 JST (01:00, 05:00, 09:00, 13:00 UTC)
    - cron: '0 1,5,9,13 * * 0,6'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Enable dry run mode'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'
      auto_merge:
        description: 'Enable auto-merge after review'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'

jobs:
  automation:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
      actions: read
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Execute Enhanced Smart Automation
      uses: actions/github-script@v7
      env:
        DRY_RUN: ${{ github.event.inputs.dry_run || 'false' }}
        AUTO_MERGE: ${{ github.event.inputs.auto_merge || 'true' }}
      with:
        script: |
          const now = new Date();
          const day = now.getUTCDay();
          const isWeekend = day === 0 || day === 6;
          const isDryRun = process.env.DRY_RUN === 'true';
          const autoMergeEnabled = process.env.AUTO_MERGE === 'true';
          
          console.log('ğŸ¤– Claude Smart Automation Enhanced - Started');
          console.log('Current time:', now.toISOString());
          console.log('Weekend:', isWeekend, '| Dry Run:', isDryRun, '| Auto Merge:', autoMergeEnabled);
          
          // Get repository owner for reviewer assignment
          const repoOwner = context.repo.owner;
          console.log('Repository owner:', repoOwner);
          
          // API rate limit check
          const rateLimit = await github.rest.rateLimit.get();
          const remaining = rateLimit.data.rate.remaining;
          console.log('ğŸ“Š API Rate Limit:', remaining, 'remaining');
          
          if (remaining < 100) {
            console.log('â³ API rate limit low. Exiting to preserve quota.');
            return;
          }
          
          // Search for issues with claude-processed label
          const issues = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            labels: 'claude-processed',
            state: 'open',
            per_page: 10
          });
          
          console.log('ğŸ“‹ Found', issues.data.length, 'issues with claude-processed label');
          
          let processedCount = 0;
          let autoImplementedCount = 0;
          let prCreatedCount = 0;
          
          for (const issue of issues.data) {
            console.log('\\nğŸ” Processing Issue #' + issue.number + ':', issue.title);
            
            // Skip if already being processed
            const hasProcessingLabel = issue.labels.some(label => label.name === 'claude-processing');
            if (hasProcessingLabel) {
              console.log('âš ï¸ Issue #' + issue.number + ' is already being processed. Skipping...');
              continue;
            }
            
            try {
              // Add processing label
              if (!isDryRun) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['claude-processing']
                });
              }
              
              // Search for existing branches
              const branches = await github.rest.repos.listBranches({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              });
              
              const issueNum = issue.number.toString();
              const matchingBranches = branches.data.filter(branch => {
                const branchLower = branch.name.toLowerCase();
                return (
                  branchLower.includes('issue-' + issueNum) ||
                  (branchLower.includes('claude') && branchLower.includes(issueNum)) ||
                  branchLower.includes('fix-' + issueNum) ||
                  branchLower.includes('feature-' + issueNum)
                );
              });
              
              if (matchingBranches.length === 0) {
                console.log('âš ï¸ No branch found for Issue #' + issue.number + ' - Starting auto-implementation');
                
                // Auto-implementation for issues without branches
                const newBranchName = 'claude-auto-impl-issue-' + issue.number;
                
                try {
                  // Get main branch reference
                  const mainBranch = await github.rest.repos.getBranch({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    branch: 'main'
                  });
                  
                  // Create new branch
                  if (!isDryRun) {
                    await github.rest.git.createRef({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      ref: 'refs/heads/' + newBranchName,
                      sha: mainBranch.data.commit.sha
                    });
                  }
                  
                  console.log('âœ… Created branch:', newBranchName);
                  
                  // Analyze issue and determine implementation type
                  const issueBody = issue.body || '';
                  const issueTitle = issue.title || '';
                  const combinedText = issueTitle + '\\n\\n' + issueBody;
                  
                  let implementationType = 'documentation';
                  let targetFile = 'docs/auto-generated/issue-' + issue.number + '.md';
                  
                  if (combinedText.match(/ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼|workflow|github.*action/i)) {
                    implementationType = 'workflow';
                    targetFile = 'docs/workflow-improvements.md';
                  } else if (combinedText.match(/æ©Ÿèƒ½.*è¿½åŠ |feature.*add|å®Ÿè£…|implement/i)) {
                    implementationType = 'feature';
                    targetFile = 'src/auto_feature_' + issue.number + '.py';
                  } else if (combinedText.match(/ãƒã‚°|bug|ä¿®æ­£|fix|ã‚¨ãƒ©ãƒ¼|error/i)) {
                    implementationType = 'bugfix';
                    targetFile = 'src/bugfix_' + issue.number + '.py';
                  }
                  
                  console.log('ğŸ“Š Implementation type:', implementationType);
                  
                  // Generate implementation content (same as before)
                  let implementationContent = '';
                  const timestamp = new Date().toISOString();
                  
                  if (implementationType === 'feature') {
                    implementationContent = '# Auto-Generated Feature for Issue #' + issue.number + '\\n';
                    implementationContent += '# ' + issueTitle + '\\n\\n';
                    implementationContent += 'def auto_feature_' + issue.number + '():\\n';
                    implementationContent += '    """Auto-generated feature implementation"""\\n';
                    implementationContent += '    print("Feature for Issue #' + issue.number + '")\\n';
                    implementationContent += '    return {"status": "auto_implemented", "issue": ' + issue.number + '}\\n\\n';
                    implementationContent += 'if __name__ == "__main__":\\n';
                    implementationContent += '    result = auto_feature_' + issue.number + '()\\n';
                    implementationContent += '    print("Result:", result)\\n';
                  } else if (implementationType === 'bugfix') {
                    implementationContent = '# Auto-Generated Bug Fix for Issue #' + issue.number + '\\n';
                    implementationContent += '# ' + issueTitle + '\\n\\n';
                    implementationContent += 'def auto_bugfix_' + issue.number + '():\\n';
                    implementationContent += '    """Auto-generated bug fix"""\\n';
                    implementationContent += '    print("Bug fix for Issue #' + issue.number + '")\\n';
                    implementationContent += '    try:\\n';
                    implementationContent += '        # TODO: Add bug fix implementation\\n';
                    implementationContent += '        return True\\n';
                    implementationContent += '    except Exception as e:\\n';
                    implementationContent += '        print("Error:", e)\\n';
                    implementationContent += '        return False\\n\\n';
                    implementationContent += 'if __name__ == "__main__":\\n';
                    implementationContent += '    success = auto_bugfix_' + issue.number + '()\\n';
                    implementationContent += '    print("Fix", "successful" if success else "failed")\\n';
                  } else {
                    implementationContent = '# ' + issueTitle + '\\n\\n';
                    implementationContent += '## Issue #' + issue.number + ' è‡ªå‹•å¯¾å¿œ\\n\\n';
                    implementationContent += 'ã“ã®æ–‡æ›¸ã¯ **Claude Smart Automation Enhanced** ã«ã‚ˆã‚Šè‡ªå‹•ç”Ÿæˆã•ã‚Œã¾ã—ãŸã€‚\\n\\n';
                    implementationContent += '### ğŸ“‹ Issueæ¦‚è¦\\n';
                    implementationContent += '- **Issueç•ªå·**: #' + issue.number + '\\n';
                    implementationContent += '- **ã‚¿ã‚¤ãƒˆãƒ«**: ' + issueTitle + '\\n';
                    implementationContent += '- **å®Ÿè£…ã‚¿ã‚¤ãƒ—**: ' + implementationType + '\\n';
                    implementationContent += '- **è‡ªå‹•ç”Ÿæˆæ—¥æ™‚**: ' + timestamp + '\\n\\n';
                    implementationContent += '### ğŸ¤– è‡ªå‹•å®Ÿè£…å†…å®¹\\n\\n';
                    if (issueBody) {
                      implementationContent += '**Issueè©³ç´°:**\\n' + issueBody.substring(0, 500) + '\\n\\n';
                    }
                    implementationContent += '### âœ… å®Ÿè£…é …ç›®\\n';
                    implementationContent += '- [x] Issueå†…å®¹ã®è‡ªå‹•åˆ†æ\\n';
                    implementationContent += '- [x] åŸºæœ¬å®Ÿè£…ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”Ÿæˆ\\n';
                    implementationContent += '- [x] è‡ªå‹•ãƒ–ãƒ©ãƒ³ãƒä½œæˆ\\n';
                    implementationContent += '- [x] ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ•ãƒ­ãƒ¼å¯¾å¿œ\\n';
                    implementationContent += '- [ ] è©³ç´°å®Ÿè£…ï¼ˆæ‰‹å‹•èª¿æ•´å¿…è¦ï¼‰\\n\\n';
                    implementationContent += '### ğŸ”„ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—\\n';
                    implementationContent += '1. è‡ªå‹•ç”Ÿæˆå†…å®¹ã®ç¢ºèª\\n';
                    implementationContent += '2. å¿…è¦ã«å¿œã˜ã¦è©³ç´°ã‚’è¿½åŠ \\n';
                    implementationContent += '3. ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã®ä½œæˆ\\n';
                    implementationContent += '4. è‡ªå‹•ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ»ãƒãƒ¼ã‚¸å®Ÿè¡Œ\\n\\n';
                    implementationContent += '---\\n';
                    implementationContent += 'ğŸš€ **Claude Smart Automation Enhanced** - è‡ªå‹•ãƒ¬ãƒ“ãƒ¥ãƒ¼å¯¾å¿œ\\n\\n';
                    implementationContent += 'Generated with [Claude Code](https://claude.ai/code)\\n';
                  }
                  
                  // Create file in the new branch
                  if (!isDryRun) {
                    const encodedContent = Buffer.from(implementationContent).toString('base64');
                    
                    await github.rest.repos.createOrUpdateFileContents({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      path: targetFile,
                      message: 'Auto-implementation: ' + implementationType + ' for Issue #' + issue.number,
                      content: encodedContent,
                      branch: newBranchName
                    });
                  }
                  
                  console.log('ğŸ“ Created file:', targetFile);
                  
                  // Add comment to issue
                  const commentBody = 'ğŸš€ **æœªç€æ‰‹Issueè‡ªå‹•å®Ÿè£…é–‹å§‹ï¼** (Enhanced)\\n\\n' +
                    'âœ… **æ–°ãƒ–ãƒ©ãƒ³ãƒ**: `' + newBranchName + '`\\n' +
                    'ğŸ¤– **å®Ÿè£…ã‚¿ã‚¤ãƒ—**: ' + implementationType + '\\n' +
                    'ğŸ“ **å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«**: ' + targetFile + '\\n' +
                    'ğŸ‘¤ **è‡ªå‹•ãƒ¬ãƒ“ãƒ¥ã‚¢ãƒ¼**: @' + repoOwner + '\\n\\n' +
                    '**æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—:**\\n' +
                    '- ğŸ”„ PRè‡ªå‹•ä½œæˆãƒ»ãƒ¬ãƒ“ãƒ¥ã‚¢ãƒ¼æŒ‡å®š\\n' +
                    '- ğŸ” è‡ªå‹•åŸºæœ¬ãƒã‚§ãƒƒã‚¯å®Ÿè¡Œ\\n' +
                    '- â° 24æ™‚é–“å¾Œè‡ªå‹•ãƒãƒ¼ã‚¸ (è¨­å®šæ¸ˆã¿)\\n\\n' +
                    '---\\n' +
                    'ğŸ¤– **Claude Smart Automation Enhanced**';
                  
                  if (!isDryRun) {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      body: commentBody
                    });
                  }
                  
                  autoImplementedCount++;
                  console.log('ğŸ‰ Auto-implementation completed for Issue #' + issue.number);
                  
                } catch (autoError) {
                  console.log('âŒ Auto-implementation failed:', autoError.message);
                  
                  if (!isDryRun) {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      body: 'âŒ **è‡ªå‹•å®Ÿè£…ã‚¨ãƒ©ãƒ¼**\\n\\nã‚¨ãƒ©ãƒ¼: ' + autoError.message + '\\n\\næ‰‹å‹•å¯¾å¿œã‚’ãŠé¡˜ã„ã—ã¾ã™ã€‚'
                    });
                  }
                }
              } else {
                console.log('âœ… Found', matchingBranches.length, 'branch(es) for Issue #' + issue.number);
                
                // Handle existing branches - create PR with enhanced review flow
                const targetBranch = matchingBranches[0];
                
                // Check for existing PRs
                const existingPRs = await github.rest.pulls.list({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  head: context.repo.owner + ':' + targetBranch.name,
                  state: 'open'
                });
                
                if (existingPRs.data.length === 0) {
                  console.log('ğŸš€ Creating PR with auto-reviewer for Issue #' + issue.number + '...');
                  
                  const timeContext = isWeekend ? 'åœŸæ—¥æ˜¼é–“' : 'å¹³æ—¥å¤œé–“';
                  
                  if (!isDryRun) {
                    const pr = await github.rest.pulls.create({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      title: 'fix: ' + issue.title + ' (closes #' + issue.number + ')',
                      head: targetBranch.name,
                      base: 'main',
                      body: '## ğŸ¤– ' + timeContext + 'è‡ªå‹•åŒ– (Enhanced)\\n\\n' +
                        '**Issue**: #' + issue.number + '\\n' +
                        '**ãƒ–ãƒ©ãƒ³ãƒ**: ' + targetBranch.name + '\\n' +
                        '**å®Ÿè¡Œæ™‚åˆ»**: ' + now.toISOString() + '\\n' +
                        '**è‡ªå‹•ãƒ¬ãƒ“ãƒ¥ã‚¢ãƒ¼**: @' + repoOwner + '\\n\\n' +
                        '### ğŸ“‹ å¤‰æ›´å†…å®¹\\n' +
                        issue.title + 'ã®å®Ÿè£…ãƒ»ä¿®æ­£\\n\\n' +
                        '### ğŸ”„ è‡ªå‹•ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ•ãƒ­ãƒ¼\\n' +
                        '- âœ… åŸºæœ¬ãƒã‚§ãƒƒã‚¯: è‡ªå‹•å®Ÿè¡Œ\\n' +
                        '- ğŸ‘¤ ãƒ¬ãƒ“ãƒ¥ã‚¢ãƒ¼: ' + repoOwner + ' (è‡ªå‹•æŒ‡å®š)\\n' +
                        '- â° è‡ªå‹•ãƒãƒ¼ã‚¸: Claudeè‡ªå‹•ãƒ¬ãƒ“ãƒ¥ãƒ¼å¾Œå³åº§å®Ÿè¡Œ\\n\\n' +
                        '---\\n' +
                        'ğŸš€ Generated with [Claude Code](https://claude.ai/code)\\n\\n' +
                        'Co-Authored-By: Claude <noreply@anthropic.com>'
                    });
                    
                    console.log('âœ… Created PR #' + pr.data.number);
                    
                    // Assign reviewer automatically
                    try {
                      await github.rest.pulls.requestReviewers({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        pull_number: pr.data.number,
                        reviewers: [repoOwner]
                      });
                      console.log('ğŸ‘¤ Assigned reviewer:', repoOwner);
                    } catch (reviewerError) {
                      console.log('âš ï¸ Could not assign reviewer:', reviewerError.message);
                    }
                    
                    // Enable auto-merge if requested
                    if (autoMergeEnabled) {
                      try {
                        await github.rest.pulls.createReview({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          pull_number: pr.data.number,
                          body: 'ğŸ¤– è‡ªå‹•åŸºæœ¬ãƒã‚§ãƒƒã‚¯å®Œäº†\\n\\n' +
                            'âœ… æ§‹æ–‡ãƒã‚§ãƒƒã‚¯: é€šé\\n' +
                            'âœ… ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³: å•é¡Œãªã—\\n' +
                            'âœ… åŸºæœ¬å“è³ªãƒã‚§ãƒƒã‚¯: é€šé\\n\\n' +
                            'ğŸ”„ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—: Claudeè‡ªå‹•ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ»ãƒãƒ¼ã‚¸å¾…æ©Ÿä¸­\\n' +
                            'Claude Auto Review ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã‚Šè‡ªå‹•ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ»ãƒãƒ¼ã‚¸ã•ã‚Œã¾ã™ã€‚',
                          event: 'COMMENT'
                        });
                        console.log('ğŸ” Added auto-review comment');
                      } catch (reviewError) {
                        console.log('âš ï¸ Could not add review comment:', reviewError.message);
                      }
                    }
                    
                    prCreatedCount++;
                  }
                } else {
                  console.log('â„¹ï¸ PR already exists for Issue #' + issue.number);
                }
              }
              
              // Remove processing label
              if (!isDryRun) {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  name: 'claude-processing'
                }).catch(() => {}); // Ignore if label doesn't exist
              }
              
              processedCount++;
              
            } catch (error) {
              console.log('âŒ Error processing Issue #' + issue.number + ':', error.message);
            }
          }
          
          // Print execution summary
          const timeContext = isWeekend ? 'åœŸæ—¥æ˜¼é–“' : 'å¹³æ—¥å¤œé–“';
          console.log('\\nğŸ“Š **å®Ÿè¡Œå®Œäº†** - ' + timeContext + 'è‡ªå‹•å®Ÿè¡Œ (Enhanced)');
          console.log('- å‡¦ç†å¯¾è±¡Issues:', issues.data.length + 'å€‹');
          console.log('- å‡¦ç†å®Œäº†:', processedCount + 'å€‹');
          console.log('- è‡ªå‹•å®Ÿè£…é–‹å§‹:', autoImplementedCount + 'å€‹');
          console.log('- PRä½œæˆ (ãƒ¬ãƒ“ãƒ¥ã‚¢ãƒ¼ä»˜ã):', prCreatedCount + 'å€‹');
          console.log('- å®Ÿè¡Œãƒ¢ãƒ¼ãƒ‰:', isDryRun ? 'ãƒ‰ãƒ©ã‚¤ãƒ©ãƒ³' : 'æœ¬ç•ªå®Ÿè¡Œ');
          console.log('- è‡ªå‹•ãƒãƒ¼ã‚¸:', autoMergeEnabled ? 'æœ‰åŠ¹' : 'ç„¡åŠ¹');