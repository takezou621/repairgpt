name: Claude Smart Automation

on:
  schedule:
    # å¹³æ—¥: 23:00, 02:00, 05:00 JST (14:00, 17:00, 20:00 UTC)
    - cron: '0 14,17,20 * * 1-5'
    # åœŸæ—¥: 10:00, 14:00, 18:00, 22:00 JST (01:00, 05:00, 09:00, 13:00 UTC)
    - cron: '0 1,5,9,13 * * 0,6'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Enable dry run mode (true/false)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

jobs:
  smart-automation:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
      actions: read
    
    env:
      DRY_RUN: ${{ github.event.inputs.dry_run || 'false' }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Smart Issue Processing
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const now = new Date();
          const day = now.getDay(); // 0=Sunday, 6=Saturday
          const hour = now.getUTCHours();
          const isWeekend = day === 0 || day === 6;
          
          // ãƒ‰ãƒ©ã‚¤ãƒ©ãƒ³ãƒ¢ãƒ¼ãƒ‰ (ç’°å¢ƒå¤‰æ•°ã§åˆ¶å¾¡)
          const isDryRun = process.env.DRY_RUN === 'true';
          if (isDryRun) {
            console.log('ğŸ§ª DRY RUN MODE: Actions will be simulated only');
          }
          
          // å…¥åŠ›æ¤œè¨¼
          function validateInputs() {
            if (!context.repo.owner || !context.repo.repo) {
              throw new Error('Repository owner or name is missing');
            }
            return true;
          }
          
          // APIãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒã‚§ãƒƒã‚¯é–¢æ•° (ã‚¿ã‚¤ãƒŸãƒ³ã‚°ãƒã‚°ä¿®æ­£)
          async function checkRateLimit() {
            const rateLimit = await github.rest.rateLimit.get();
            const remaining = rateLimit.data.rate.remaining;
            const resetTime = new Date(rateLimit.data.rate.reset * 1000);
            const currentTime = new Date(); // ç¾åœ¨æ™‚åˆ»ã‚’å‹•çš„å–å¾—
            
            console.log(`ğŸ“Š API Rate Limit: ${remaining} remaining`);
            console.log(`ğŸ”„ Reset time: ${resetTime.toISOString()}`);
            
            // æ®‹ã‚ŠãŒ100æœªæº€ã®å ´åˆã¯å¾…æ©Ÿ
            if (remaining < 100) {
              const waitTime = Math.max(0, resetTime - currentTime); // è² ã®å€¤ã‚’é˜²æ­¢
              const waitMinutes = Math.ceil(waitTime / 1000 / 60);
              console.log(`â³ API rate limit low. Waiting ${waitMinutes} minutes...`);
              
              if (waitTime > 0 && waitTime < 3600000) { // 1æ™‚é–“ä»¥å†…ã®ã¿å¾…æ©Ÿ
                if (isDryRun) {
                  console.log('ğŸ§ª DRY RUN: Skipping actual wait');
                } else {
                  await new Promise(resolve => setTimeout(resolve, waitTime));
                }
              } else if (waitTime >= 3600000) {
                throw new Error(`Wait time too long: ${waitMinutes} minutes. Aborting.`);
              }
            }
            
            return remaining;
          }
          
          console.log(`ğŸ¤– Claude Smart Automation started`);
          console.log(`Current time: ${now.toISOString()}`);
          console.log(`Day: ${day}, Hour: ${hour}UTC, Weekend: ${isWeekend}`);
          
          // å…¥åŠ›æ¤œè¨¼
          validateInputs();
          
          // APIã‚³ãƒ¼ãƒ«å‰ã«ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã‚’ãƒã‚§ãƒƒã‚¯
          await checkRateLimit();
          
          // Issueæ¤œç´¢
          const issues = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            labels: 'claude-processed',
            state: 'open',
            sort: 'created',
            direction: 'asc'
          });

          if (issues.data.length === 0) {
            console.log('âœ… No issues to process');
            return;
          }

          console.log(`ğŸ“‹ Found ${issues.data.length} issues for processing`);

          for (const issue of issues.data) {
            console.log(`\nğŸ” Processing Issue #${issue.number}: ${issue.title}`);
            
            // é‡è¤‡å®Ÿè¡Œé˜²æ­¢: processing ãƒ©ãƒ™ãƒ«ã®ãƒã‚§ãƒƒã‚¯
            const hasProcessingLabel = issue.labels.some(label => label.name === 'claude-processing');
            if (hasProcessingLabel) {
              console.log(`âš ï¸ Issue #${issue.number} is already being processed. Skipping...`);
              continue;
            }
            
            try {
              // å‡¦ç†é–‹å§‹ã‚’ç¤ºã™ãƒ©ãƒ™ãƒ«ã‚’è¿½åŠ 
              if (isDryRun) {
                console.log('ğŸ§ª DRY RUN: Would add label "claude-processing" to Issue #' + issue.number);
              } else {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['claude-processing']
                });
              }
              
              // APIãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒã‚§ãƒƒã‚¯
              await checkRateLimit();
              // ãƒ–ãƒ©ãƒ³ãƒæ¤œç´¢ï¼ˆæŸ”è»Ÿãªãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°ï¼‰
              const branches = await github.rest.repos.listBranches({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              });
              
              // Instead of strict patterns, use inclusive search
              const claudeBranches = branches.data.filter(branch => {
                const branchLower = branch.name.toLowerCase();
                const issueNum = issue.number.toString();
                
                return (
                  branchLower.includes(`issue-${issueNum}`) ||
                  (branchLower.includes(`claude`) && branchLower.includes(issueNum)) ||
                  branchLower.includes(`fix-${issueNum}`) ||
                  branchLower.includes(`feature-${issueNum}`)
                );
              });
              
              if (claudeBranches.length === 0) {
                console.log(`âš ï¸ No branch found for Issue #${issue.number} - Starting automatic implementation`);
                
                // ğŸš€ PHASE 1: æœªç€æ‰‹Issueè‡ªå‹•å®Ÿè£…æ©Ÿèƒ½
                const newBranchName = `claude-auto-impl-issue-${issue.number}`;
                
                try {
                  // æ–°ã—ã„ãƒ–ãƒ©ãƒ³ãƒã‚’ä½œæˆ
                  const mainBranch = await github.rest.repos.getBranch({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    branch: 'main'
                  });
                  
                  if (isDryRun) {
                    console.log(`ğŸ§ª DRY RUN: Would create branch ${newBranchName}`);
                  } else {
                    await github.rest.git.createRef({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      ref: `refs/heads/${newBranchName}`,
                      sha: mainBranch.data.commit.sha
                    });
                  }
                  
                  console.log(`âœ… Created new branch: ${newBranchName}`);
                  
                  // Issueå†…å®¹ã‚’åˆ†æã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«å¤‰æ›´ã‚’æ±ºå®š
                  const issueBody = issue.body || '';
                  const issueTitle = issue.title || '';
                  const combinedText = `${issueTitle}\n\n${issueBody}`;
                  
                  // ğŸ¤– Claude Codeé¢¨ã®ç°¡æ˜“å®Ÿè£…åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯
                  let implementationType = 'documentation';
                  let targetFiles = [];
                  let implementationContent = '';
                  
                  // å®Ÿè£…ã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
                  if (combinedText.match(/ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼|workflow|github.*action/i)) {
                    implementationType = 'workflow';
                    targetFiles = ['.github/workflows/claude-smart-automation.yml'];
                  } else if (combinedText.match(/æ©Ÿèƒ½.*è¿½åŠ |feature.*add|å®Ÿè£…|implement/i)) {
                    implementationType = 'feature';
                    targetFiles = ['src/new-feature.py', 'tests/test_new_feature.py'];
                  } else if (combinedText.match(/ãƒã‚°|bug|ä¿®æ­£|fix|ã‚¨ãƒ©ãƒ¼|error/i)) {
                    implementationType = 'bugfix';
                    targetFiles = ['src/bugfix.py'];
                  } else if (combinedText.match(/ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ|document|docs|readme/i)) {
                    implementationType = 'documentation';
                    targetFiles = [`docs/auto-generated/issue-${issue.number}.md`];
                  }
                  
                  // å®Ÿè£…å†…å®¹ã‚’ç”Ÿæˆ
                  if (implementationType === 'workflow') {
                    implementationContent = `# GitHub Actions ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼æ”¹å–„ (Issue #${issue.number})
# ${issueTitle}

# ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ Claude Smart Automation ã«ã‚ˆã‚Šè‡ªå‹•ç”Ÿæˆã•ã‚Œã¾ã—ãŸ
# å®Ÿè£…è©³ç´°:
# - Issueåˆ†æ: ${implementationType}
# - å¯¾è±¡: GitHub Actions ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼
# - è‡ªå‹•åŒ–ãƒ¬ãƒ™ãƒ«: 100%

# âš ï¸ ã“ã®å®Ÿè£…ã¯åŸºæœ¬ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã§ã™
# è©³ç´°ãªå®Ÿè£…ã¯æ‰‹å‹•ã§èª¿æ•´ã—ã¦ãã ã•ã„

# ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼æ”¹å–„ææ¡ˆ:
# 1. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®å¼·åŒ–
# 2. ãƒ­ã‚°å‡ºåŠ›ã®æ”¹å–„  
# 3. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

# å‚è€ƒIssue: https://github.com/${context.repo.owner}/${context.repo.repo}/issues/${issue.number}
`;
                  } else if (implementationType === 'feature') {
                    implementationContent = `# ${issueTitle} - è‡ªå‹•å®Ÿè£…
# Issue #${issue.number} ã®è‡ªå‹•å®Ÿè£…

def auto_implemented_feature():
    """
    Claude Smart Automation ã«ã‚ˆã‚‹è‡ªå‹•å®Ÿè£…
    
    ã“ã®é–¢æ•°ã¯ Issue #${issue.number} ã®è¦æ±‚ã«åŸºã¥ã„ã¦
    è‡ªå‹•ç”Ÿæˆã•ã‚Œã¾ã—ãŸã€‚
    
    TODO: å…·ä½“çš„ãªå®Ÿè£…å†…å®¹ã‚’è¿½åŠ ã—ã¦ãã ã•ã„
    """
    
    print(f"æ–°æ©Ÿèƒ½å®Ÿè£…: {issue.title}")
    
    # åŸºæœ¬å®Ÿè£…ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
    return {
        'status': 'auto_implemented',
        'issue_number': ${issue.number},
        'implementation_type': '${implementationType}',
        'requires_manual_review': True
    }

if __name__ == "__main__":
    result = auto_implemented_feature()
    print(f"å®Ÿè£…çµæœ: {result}")
`;
                  } else if (implementationType === 'bugfix') {
                    implementationContent = `# Bug Fix for Issue #${issue.number}
# ${issueTitle}

def auto_bugfix():
    """
    Claude Smart Automation ã«ã‚ˆã‚‹è‡ªå‹•ãƒã‚°ä¿®æ­£
    
    Issue #${issue.number} ã§å ±å‘Šã•ã‚ŒãŸãƒã‚°ã®
    è‡ªå‹•ä¿®æ­£å®Ÿè£…ã§ã™ã€‚
    
    âš ï¸ ã“ã®ä¿®æ­£ã¯åŸºæœ¬ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã§ã™
    å®Ÿéš›ã®ãƒã‚°å†…å®¹ã«å¿œã˜ã¦èª¿æ•´ãŒå¿…è¦ã§ã™
    """
    
    print(f"ãƒã‚°ä¿®æ­£å®Ÿè£…: ${issue.title}")
    
    # ä¸€èˆ¬çš„ãªãƒã‚°ä¿®æ­£ãƒ‘ã‚¿ãƒ¼ãƒ³
    try:
        # ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°è¿½åŠ 
        pass  # TODO: å®Ÿéš›ã®ãƒã‚°ä¿®æ­£ã‚³ãƒ¼ãƒ‰
    except Exception as e:
        print(f"ä¿®æ­£å‡¦ç†ã‚¨ãƒ©ãƒ¼: {e}")
        return False
    
    return True

# ä¿®æ­£ãƒ†ã‚¹ãƒˆ
if __name__ == "__main__":
    if auto_bugfix():
        print("âœ… ãƒã‚°ä¿®æ­£å®Œäº†")
    else:
        print("âŒ ãƒã‚°ä¿®æ­£å¤±æ•—")
`;
                  } else {
                    implementationContent = `# ${issueTitle}

## Issue #${issue.number} è‡ªå‹•å¯¾å¿œ

ã“ã®æ–‡æ›¸ã¯ **Claude Smart Automation** ã«ã‚ˆã‚Šè‡ªå‹•ç”Ÿæˆã•ã‚Œã¾ã—ãŸã€‚

### ğŸ“‹ Issueæ¦‚è¦
- **Issueç•ªå·**: #${issue.number}
- **ã‚¿ã‚¤ãƒˆãƒ«**: ${issueTitle}
- **å®Ÿè£…ã‚¿ã‚¤ãƒ—**: ${implementationType}
- **è‡ªå‹•ç”Ÿæˆæ—¥æ™‚**: ${new Date().toISOString()}

### ğŸ¤– è‡ªå‹•å®Ÿè£…å†…å®¹

${issueBody ? '**Issueè©³ç´°:**\n' + issueBody + '\n' : ''}

### âœ… å®Ÿè£…é …ç›®
- [x] Issueå†…å®¹ã®è‡ªå‹•åˆ†æ
- [x] åŸºæœ¬å®Ÿè£…ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”Ÿæˆ
- [x] PRè‡ªå‹•ä½œæˆ
- [ ] è©³ç´°å®Ÿè£…ï¼ˆæ‰‹å‹•èª¿æ•´å¿…è¦ï¼‰
- [ ] ãƒ†ã‚¹ãƒˆå®Ÿè£…
- [ ] ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°

### ğŸ”„ æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—
1. ç”Ÿæˆã•ã‚ŒãŸå®Ÿè£…å†…å®¹ã‚’ç¢ºèª
2. å¿…è¦ã«å¿œã˜ã¦è©³ç´°ã‚’è¿½åŠ 
3. ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã®ä½œæˆ
4. æœ€çµ‚çš„ãªå‹•ä½œç¢ºèª

### ğŸ“Š è‡ªå‹•åŒ–çµ±è¨ˆ
- **å‡¦ç†æ™‚é–“**: è‡ªå‹•
- **å®Ÿè£…ãƒ•ã‚¡ã‚¤ãƒ«æ•°**: ${targetFiles.length}
- **è‡ªå‹•åŒ–ãƒ¬ãƒ™ãƒ«**: åŸºæœ¬å®Ÿè£…å®Œäº†

---
ğŸš€ **Claude Smart Automation** - æœªç€æ‰‹Issueè‡ªå‹•å®Ÿè£…ã‚·ã‚¹ãƒ†ãƒ 

Generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>
`;
                  }
                  
                  // ãƒ•ã‚¡ã‚¤ãƒ«ã®ä½œæˆã¾ãŸã¯æ›´æ–°
                  for (const filePath of targetFiles) {
                    try {
                      if (isDryRun) {
                        console.log(`ğŸ§ª DRY RUN: Would create/update file ${filePath}`);
                      } else {
                        // ãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ç¢ºèª
                        let fileExists = false;
                        let currentSha = null;
                        
                        try {
                          const existingFile = await github.rest.repos.getContent({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            path: filePath,
                            ref: newBranchName
                          });
                          fileExists = true;
                          currentSha = existingFile.data.sha;
                        } catch (e) {
                          // ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆ
                          fileExists = false;
                        }
                        
                        const encodedContent = Buffer.from(implementationContent).toString('base64');
                        
                        if (fileExists) {
                          // ãƒ•ã‚¡ã‚¤ãƒ«æ›´æ–°
                          await github.rest.repos.createOrUpdateFileContents({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            path: filePath,
                            message: `Auto-implementation: Update ${filePath} for Issue #${issue.number}`,
                            content: encodedContent,
                            branch: newBranchName,
                            sha: currentSha
                          });
                        } else {
                          // ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ
                          await github.rest.repos.createOrUpdateFileContents({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            path: filePath,
                            message: `Auto-implementation: Create ${filePath} for Issue #${issue.number}`,
                            content: encodedContent,
                            branch: newBranchName
                          });
                        }
                      }
                      
                      console.log(`ğŸ“ Created/Updated: ${filePath}`);
                    } catch (fileError) {
                      console.log(`âš ï¸ Failed to create/update ${filePath}: ${fileError.message}`);
                    }
                  }
                  
                  // è‡ªå‹•å®Ÿè£…å®Œäº†ã‚³ãƒ¡ãƒ³ãƒˆ
                  if (isDryRun) {
                    console.log('ğŸ§ª DRY RUN: Would add auto-implementation comment');
                  } else {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      body: [
                        'ğŸš€ **æœªç€æ‰‹Issueè‡ªå‹•å®Ÿè£…é–‹å§‹ï¼**',
                        '',
                        `âœ… **æ–°ãƒ–ãƒ©ãƒ³ãƒä½œæˆ**: \`${newBranchName}\``,
                        `ğŸ¤– **å®Ÿè£…ã‚¿ã‚¤ãƒ—**: ${implementationType}`,
                        `ğŸ“ **å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«**: ${targetFiles.length}å€‹`,
                        '',
                        '**è‡ªå‹•å®Ÿè£…å†…å®¹:**',
                        ...targetFiles.map(file => `- ğŸ“„ ${file}`),
                        '',
                        '**æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—:**',
                        '- ğŸ”„ PRè‡ªå‹•ä½œæˆä¸­...',
                        '- ğŸ“Š åŸºæœ¬å®Ÿè£…ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆç”Ÿæˆæ¸ˆã¿',
                        '- âš ï¸ è©³ç´°å®Ÿè£…ã¯æ‰‹å‹•èª¿æ•´ãŒå¿…è¦ã§ã™',
                        '',
                        '---',
                        'ğŸ¤– **Claude Smart Automation** - æœªç€æ‰‹Issueè‡ªå‹•å®Ÿè£…æ©Ÿèƒ½'
                      ].join('\n')
                    });
                  }
                  
                  // æ–°ã—ãä½œæˆã—ãŸãƒ–ãƒ©ãƒ³ãƒã‚’ä½¿ç”¨ã—ã¦å‡¦ç†ã‚’ç¶šè¡Œ
                  const newTargetBranch = { name: newBranchName };
                  console.log(`ğŸ”„ Continuing with auto-created branch: ${newBranchName}`);
                  
                  // ã“ã“ã§æ—¢å­˜ã®å‡¦ç†ãƒ•ãƒ­ãƒ¼ã«æˆ»ã‚‹ï¼ˆPRä½œæˆç­‰ï¼‰
                  // targetBranchã‚’æ–°ã—ã„ãƒ–ãƒ©ãƒ³ãƒã«è¨­å®š
                  claudeBranches = [newTargetBranch];
                  
                } catch (autoImplError) {
                  console.log(`âŒ Auto-implementation failed for Issue #${issue.number}: ${autoImplError.message}`);
                  
                  // ã‚¨ãƒ©ãƒ¼æ™‚ã®ã‚³ãƒ¡ãƒ³ãƒˆ
                  try {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      body: [
                        'âŒ **è‡ªå‹•å®Ÿè£…ã‚¨ãƒ©ãƒ¼**',
                        '',
                        `ã‚¨ãƒ©ãƒ¼è©³ç´°: ${autoImplError.message}`,
                        '',
                        'æ‰‹å‹•ã§ãƒ–ãƒ©ãƒ³ãƒä½œæˆã¨å®Ÿè£…ã‚’ãŠé¡˜ã„ã—ã¾ã™ã€‚',
                        '',
                        '---',
                        'ğŸ¤– Claude Smart Automation - ã‚¨ãƒ©ãƒ¼ãƒ¬ãƒãƒ¼ãƒˆ'
                      ].join('\n')
                    });
                  } catch (commentError) {
                    console.log(`Failed to add error comment: ${commentError.message}`);
                  }
                  
                  continue; // æ¬¡ã®Issueã«é€²ã‚€
                }
              }
              
              // æ—¢å­˜ãƒ–ãƒ©ãƒ³ãƒã¾ãŸã¯æ–°è¦ä½œæˆãƒ–ãƒ©ãƒ³ãƒãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆã®å‡¦ç†
              if (claudeBranches.length === 0) {
                console.log(`âŒ No valid branch available for Issue #${issue.number}`);
                continue;
              }
              
              // Use the first matching branch
              const targetBranch = claudeBranches[0];
              console.log(`âœ… Found branch: ${targetBranch.name} for Issue #${issue.number}`);
              
              if (claudeBranches.length > 1) {
                console.log(`â„¹ï¸ Multiple branches found: ${claudeBranches.map(b => b.name).join(', ')}`);
              }
              
              // æ—¢å­˜PRç¢ºèª
              const existingPRs = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head: `${context.repo.owner}:${targetBranch.name}`,
                state: 'all'
              });
              
              if (existingPRs.data.length > 0) {
                console.log(`ğŸ“ PR already exists: #${existingPRs.data[0].number}`);
                continue;
              }
              
              // PRä½œæˆ
              console.log(`ğŸš€ Creating PR for Issue #${issue.number}...`);
              
              const timeContext = isWeekend ? 'åœŸæ—¥æ˜¼é–“' : 'å¹³æ—¥å¤œé–“';
              let pr;
              
              if (isDryRun) {
                console.log('ğŸ§ª DRY RUN: Would create PR for Issue #' + issue.number);
                pr = { data: { number: 999, html_url: 'https://github.com/mock/pr/999' } }; // ãƒ¢ãƒƒã‚¯PR
              } else {
                pr = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `fix: ${issue.title} (closes #${issue.number})`,
                head: targetBranch.name,
                base: 'main',
                body: [
                  '## ğŸ¤– ã‚¹ãƒãƒ¼ãƒˆè‡ªå‹•åŒ–ã‚·ã‚¹ãƒ†ãƒ ',
                  '',
                  '### ğŸ• å®Ÿè¡Œã‚¿ã‚¤ãƒŸãƒ³ã‚°',
                  `- **å®Ÿè¡Œæ™‚åˆ»**: ${now.toISOString()}`,
                  `- **å®Ÿè¡Œãƒ¢ãƒ¼ãƒ‰**: ${timeContext}è‡ªå‹•å®Ÿè¡Œ`,
                  `- **æ›œæ—¥**: ${['æ—¥', 'æœˆ', 'ç«', 'æ°´', 'æœ¨', 'é‡‘', 'åœŸ'][day]}æ›œæ—¥`,
                  '',
                  '### ğŸ“‹ é–¢é€£Issue',
                  `Closes #${issue.number}`,
                  '',
                  '### ğŸ”„ è‡ªå‹•åŒ–ãƒ•ãƒ­ãƒ¼',
                  '- [x] âœ… Issueè‡ªå‹•æ¤œçŸ¥',
                  '- [x] âœ… ãƒ–ãƒ©ãƒ³ãƒè‡ªå‹•ç™ºè¦‹',
                  '- [x] âœ… PRè‡ªå‹•ä½œæˆ',
                  '- [ ] ğŸ”„ è‡ªå‹•ãƒãƒ¼ã‚¸å®Ÿè¡Œä¸­',
                  '- [ ] ğŸ”„ Issueè‡ªå‹•ã‚¯ãƒ­ãƒ¼ã‚º',
                  '- [ ] ğŸ”„ ãƒ–ãƒ©ãƒ³ãƒè‡ªå‹•å‰Šé™¤',
                  '',
                  '### ğŸ“Š å®Ÿè¡Œè©³ç´°',
                  `- **Branch**: \`${targetBranch.name}\``,
                  `- **å®Ÿè¡Œç’°å¢ƒ**: GitHub Actions (${timeContext})`,
                  `- **è‡ªå‹•åŒ–ãƒ¬ãƒ™ãƒ«**: 100%å®Œå…¨è‡ªå‹•`,
                  '',
                  '---',
                  'ğŸš€ **ã‚¹ãƒãƒ¼ãƒˆè‡ªå‹•åŒ–é”æˆ** | Generated with [Claude Code](https://claude.ai/code)',
                  '',
                  'Co-Authored-By: Claude <noreply@anthropic.com>'
                ].join('\n')
                });
              }
              
              console.log(`âœ… Created PR #${pr.data.number}: ${pr.data.html_url}`);
              
              // ãƒ©ãƒ™ãƒ«è¿½åŠ 
              if (isDryRun) {
                console.log('ğŸ§ª DRY RUN: Would add labels to PR #' + pr.data.number);
              } else {
                await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.data.number,
                labels: ['claude-auto-generated', 'smart-automation']
                });
              }
              
              // è‡ªå‹•ãƒãƒ¼ã‚¸ã®å¾…æ©Ÿ
              console.log('â³ Waiting before auto-merge...');
              if (isDryRun) {
                console.log('ğŸ§ª DRY RUN: Skipping wait time');
              } else {
                await new Promise(resolve => setTimeout(resolve, 5000));
              }
              
              // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯å®Ÿè¡Œ
              console.log('ğŸ”’ Running security checks...');
              const securityIssues = [];
              
              // PRã®å¤‰æ›´ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å–å¾—
              let prFiles;
              if (isDryRun) {
                console.log('ğŸ§ª DRY RUN: Using mock PR files');
                prFiles = { data: [] }; // ãƒ¢ãƒƒã‚¯ãƒ•ã‚¡ã‚¤ãƒ«ãƒªã‚¹ãƒˆ
              } else {
                prFiles = await github.rest.pulls.listFiles({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.data.number
                });
              }
              
              // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒªã‚¹ã‚¯ã®ã‚ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¿ãƒ¼ãƒ³
              const riskyPatterns = [
                /\.env$/,
                /\.env\./,
                /secret/i,
                /password/i,
                /token/i,
                /key/i,
                /credential/i,
                /config\/production/,
                /\.pem$/,
                /\.key$/,
                /\.crt$/
              ];
              
              // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒªã‚¹ã‚¯ã®ã‚ã‚‹ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒ‘ã‚¿ãƒ¼ãƒ³
              const riskyContentPatterns = [
                /password\s*=\s*['""][^'"]{8,}/i,
                /token\s*=\s*['""][^'"]{20,}/i,
                /api_key\s*=\s*['""][^'"]{20,}/i,
                /secret\s*=\s*['""][^'"]{10,}/i,
                /-----BEGIN.*PRIVATE KEY-----/i
              ];
              
              for (const file of prFiles.data) {
                // ãƒ•ã‚¡ã‚¤ãƒ«åãƒã‚§ãƒƒã‚¯
                const isRiskyFile = riskyPatterns.some(pattern => pattern.test(file.filename));
                if (isRiskyFile) {
                  securityIssues.push(`ğŸš¨ Risky file: ${file.filename}`);
                }
                
                // ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ãƒã‚§ãƒƒã‚¯ï¼ˆãƒ‘ãƒƒãƒå†…å®¹ï¼‰
                if (file.patch) {
                  const hasRiskyContent = riskyContentPatterns.some(pattern => pattern.test(file.patch));
                  if (hasRiskyContent) {
                    securityIssues.push(`ğŸš¨ Risky content in: ${file.filename}`);
                  }
                }
              }
              
              // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å•é¡ŒãŒç™ºè¦‹ã•ã‚ŒãŸå ´åˆã®å‡¦ç†
              if (securityIssues.length > 0) {
                console.log(`âŒ Security issues found: ${securityIssues.length}`);
                securityIssues.forEach(issue => console.log(issue));
                
                // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è­¦å‘Šã‚³ãƒ¡ãƒ³ãƒˆã‚’è¿½åŠ 
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.data.number,
                  body: [
                    'ğŸš¨ **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯: è­¦å‘Š**',
                    '',
                    'ã“ã® PR ã«ã¯æ½œåœ¨çš„ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒªã‚¹ã‚¯ãŒå«ã¾ã‚Œã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ï¼š',
                    '',
                    ...securityIssues.map(issue => `- ${issue}`),
                    '',
                    'âš ï¸ **è‡ªå‹•ãƒãƒ¼ã‚¸ã‚’åœæ­¢ã—ã¾ã—ãŸ**',
                    '',
                    'æ‰‹å‹•ãƒ¬ãƒ“ãƒ¥ãƒ¼ãŒå¿…è¦ã§ã™ã€‚æ©Ÿå¯†æƒ…å ±ãŒå«ã¾ã‚Œã¦ã„ãªã„ã“ã¨ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚',
                    '',
                    '---',
                    'ğŸ¤– è‡ªå‹•ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯'
                  ].join('\n')
                });
                
                // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ©ãƒ™ãƒ«ã‚’è¿½åŠ 
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.data.number,
                  labels: ['security-review-required', 'blocked-auto-merge']
                });
                
                console.log('ğŸ›‘ Auto-merge blocked due to security concerns');
                continue; // æ¬¡ã®Issueã«é€²ã‚€
              }
              
              console.log('âœ… Security checks passed');
              
              // è‡ªå‹•ãƒãƒ¼ã‚¸å®Ÿè¡Œ
              try {
                if (isDryRun) {
                  console.log('ğŸ§ª DRY RUN: Would merge PR #' + pr.data.number);
                } else {
                  await github.rest.pulls.merge({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: pr.data.number,
                    commit_title: `Smart automation: ${issue.title} (#${issue.number})`,
                    commit_message: `${timeContext}ã‚¹ãƒãƒ¼ãƒˆè‡ªå‹•åŒ–ã«ã‚ˆã‚‹ãƒãƒ¼ã‚¸\n\nğŸš€ Generated with [Claude Code](https://claude.ai/code)\n\nCo-Authored-By: Claude <noreply@anthropic.com>`,
                    merge_method: 'squash'
                  });
                }
                
                console.log(`ğŸ‰ Successfully merged PR #${pr.data.number}`);
                
                // æˆåŠŸé€šçŸ¥
                if (isDryRun) {
                  console.log('ğŸ§ª DRY RUN: Would add success comment to Issue #' + issue.number);
                } else {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: [
                      'âœ… **ã‚¹ãƒãƒ¼ãƒˆè‡ªå‹•åŒ–å®Œäº†ï¼**',
                      '',
                      `ğŸ• **å®Ÿè¡Œæ™‚åˆ»**: ${now.toISOString()}`,
                      `ğŸ“… **å®Ÿè¡Œãƒ¢ãƒ¼ãƒ‰**: ${timeContext}è‡ªå‹•å®Ÿè¡Œ`,
                      '',
                      '**å®Ÿè¡Œå†…å®¹:**',
                      '- ğŸ” Issueè‡ªå‹•æ¤œçŸ¥ãƒ»å‡¦ç†',
                      `- ğŸ“ PRè‡ªå‹•ä½œæˆ: #${pr.data.number}`,
                      '- âœ… è‡ªå‹•ãƒãƒ¼ã‚¸å®Œäº†',
                      '- ğŸ§¹ ãƒ–ãƒ©ãƒ³ãƒã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Ÿè¡Œä¸­',
                      '',
                      `**PR**: ${pr.data.html_url}`,
                      '',
                      '---',
                      'ğŸš€ **ã‚¹ãƒãƒ¼ãƒˆè‡ªå‹•åŒ–ã‚·ã‚¹ãƒ†ãƒ ** | Claude Code + GitHub Actions'
                    ].join('\n')
                  });
                }
                
                // Issueå®Œäº†å‡¦ç†
                if (isDryRun) {
                  console.log('ğŸ§ª DRY RUN: Would close Issue #' + issue.number);
                } else {
                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    state: 'closed'
                  });
                  
                  // å‡¦ç†å®Œäº†ãƒ©ãƒ™ãƒ«ã‚’è¿½åŠ ã—ã€processingãƒ©ãƒ™ãƒ«ã‚’å‰Šé™¤
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    labels: ['claude-completed', 'smart-automation']
                  });
                  
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    name: 'claude-processing'
                  });
                }
                
                console.log(`ğŸ”’ Closed Issue #${issue.number}`);
                
                // ãƒ–ãƒ©ãƒ³ãƒå‰Šé™¤
                if (isDryRun) {
                  console.log('ğŸ§ª DRY RUN: Would delete branch ' + targetBranch.name);
                } else {
                  await new Promise(resolve => setTimeout(resolve, 2000));
                  
                  try {
                    await github.rest.git.deleteRef({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      ref: `heads/${targetBranch.name}`
                    });
                    
                    console.log(`ğŸ—‘ï¸ Deleted branch ${targetBranch.name}`);
                  } catch (deleteError) {
                    console.log(`âš ï¸ Branch deletion failed: ${deleteError.message}`);
                  }
                }
                
                console.log(`ğŸ¯ SMART AUTOMATION COMPLETED FOR ISSUE #${issue.number}!`);
                
              } catch (mergeError) {
                console.log(`âŒ Merge failed for PR #${pr.data.number}: ${mergeError.message}`);
                
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: [
                    'âš ï¸ ã‚¹ãƒãƒ¼ãƒˆè‡ªå‹•åŒ–: ãƒãƒ¼ã‚¸ã‚¨ãƒ©ãƒ¼',
                    '',
                    `PR #${pr.data.number}: ${pr.data.html_url}`,
                    '',
                    `ã‚¨ãƒ©ãƒ¼: ${mergeError.message}`,
                    '',
                    'æ‰‹å‹•ãƒãƒ¼ã‚¸ãŒå¿…è¦ã§ã™ã€‚'
                  ].join('\n')
                });
              }
              
            } catch (error) {
              console.log(`âŒ Error processing Issue #${issue.number}: ${error.message}`);
              
              // ã‚¨ãƒ©ãƒ¼æ™‚ã¯processingãƒ©ãƒ™ãƒ«ã‚’å‰Šé™¤
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  name: 'claude-processing'
                });
              } catch (removeLabelError) {
                // ãƒ©ãƒ™ãƒ«å‰Šé™¤ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
              }
              
              // é‡å¤§ã‚¨ãƒ©ãƒ¼ã®å ´åˆã€æ–°ã—ã„Issueã‚’ä½œæˆ
              if (error.status === 500 || error.status === 502 || error.status === 503) {
                try {
                  await github.rest.issues.create({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    title: `[è‡ªå‹•åŒ–ã‚¨ãƒ©ãƒ¼] Issue #${issue.number} ã®å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿ`,
                    body: [
                      '## ã‚¨ãƒ©ãƒ¼è©³ç´°',
                      '',
                      `- **å…ƒã®Issue**: #${issue.number}`,
                      `- **ã‚¨ãƒ©ãƒ¼æ™‚åˆ»**: ${now.toISOString()}`,
                      `- **ã‚¨ãƒ©ãƒ¼ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹**: ${error.status}`,
                      `- **ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸**: ${error.message}`,
                      '',
                      '## ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹',
                      '```',
                      error.stack || 'ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ãªã—',
                      '```',
                      '',
                      '---',
                      'ğŸ¤– è‡ªå‹•ç”Ÿæˆã•ã‚ŒãŸã‚¨ãƒ©ãƒ¼ãƒ¬ãƒãƒ¼ãƒˆ'
                    ].join('\n'),
                    labels: ['bug', 'automation-error', 'high-priority']
                  });
                  console.log('ğŸ“ Created error issue for critical error');
                } catch (issueError) {
                  console.log(`Failed to create error issue: ${issueError.message}`);
                }
              }
              
              try {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: [
                    'âŒ ã‚¹ãƒãƒ¼ãƒˆè‡ªå‹•åŒ–ã‚¨ãƒ©ãƒ¼',
                    '',
                    `ã‚¨ãƒ©ãƒ¼: ${error.message}`,
                    `å®Ÿè¡Œæ™‚åˆ»: ${now.toISOString()}`,
                    '',
                    'æ‰‹å‹•ç¢ºèªã‚’ãŠé¡˜ã„ã—ã¾ã™ã€‚'
                  ].join('\n')
                });
              } catch (commentError) {
                console.log(`Failed to add error comment: ${commentError.message}`);
              }
            }
          }
          
          // ğŸ’¡ å®Ÿè¡Œçµ±è¨ˆã¨ã‚µãƒãƒªãƒ¼
          console.log('\nğŸ“Š === EXECUTION SUMMARY ===');
          console.log(`ğŸ• å®Ÿè¡Œæ™‚åˆ»: ${now.toISOString()}`);
          console.log(`ğŸ“‹ å‡¦ç†å¯¾è±¡Issueæ•°: ${issues.data.length}`);
          console.log(`â° å®Ÿè¡Œãƒ¢ãƒ¼ãƒ‰: ${isWeekend ? 'åœŸæ—¥æ˜¼é–“' : 'å¹³æ—¥å¤œé–“'}è‡ªå‹•å®Ÿè¡Œ`);
          console.log(`ğŸ¤– è‡ªå‹•åŒ–æ©Ÿèƒ½: æœªç€æ‰‹Issueè‡ªå‹•å®Ÿè£…å¯¾å¿œæ¸ˆã¿`);
          console.log('========================');
          
          console.log('\nğŸš€ Claude Smart Automation completed!');