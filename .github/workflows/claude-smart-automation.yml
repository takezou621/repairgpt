name: Claude Smart Automation

on:
  schedule:
    # Âπ≥Êó•Â§úÈñìÂÆüË°å (23:00, 02:00, 05:00 JST)
    - cron: '0 14,17,20 * * 1-5'  # UTCÊôÇÈñì Êúà-Èáë
    # ÂúüÊó•ÊòºÈñìÂÆüË°å (10:00, 14:00, 16:00, 18:00, 22:00 JST)
    - cron: '0 1,5,7,9,13 * * 0,6'  # UTCÊôÇÈñì ÂúüÊó•
  workflow_dispatch:
    inputs:
      test_mode:
        description: 'Test mode execution'
        required: false
        default: 'false'

jobs:
  smart-automation:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
      actions: read
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
        ref: main
    
    - name: Smart Automation Processing
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          console.log('üöÄ SMART AUTOMATION START');
          const now = new Date();
          console.log(`Execution time: ${now.toISOString()}`);
          
          try {
            // ÂÖ®„Ç™„Éº„Éó„É≥Issue„ÇíÂèñÂæó
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 50
            });
            
            console.log(`Found ${issues.data.length} open issues`);
            
            // smart-automation„É©„Éô„É´„Åå„ÅÇ„ÇãIssue„ÇíÊ§úÁ¥¢Ôºà100%Ëá™ÂãïÂåñÂØæË±°Ôºâ
            const smartAutomationIssues = issues.data.filter(issue => 
              issue.labels.some(label => label.name === 'smart-automation')
            );
            
            // claude-processed„É©„Éô„É´„Åå„ÅÇ„ÇãIssueÔºàÂÆüË£ÖÊ∏à„ÅøÔºâ„ÇíÊ§úÁ¥¢
            const processedIssues = issues.data.filter(issue => 
              issue.labels.some(label => label.name === 'claude-processed')
            );
            
            console.log(`Found ${smartAutomationIssues.length} smart-automation issues`);
            console.log(`Found ${processedIssues.length} Claude-processed issues`);
            
            // Phase 1: smart-automation„É©„Éô„É´„ÅÆIssue„ÇíËá™ÂãïÂÆüË£Ö
            for (const issue of smartAutomationIssues) {
              console.log(`\nü§ñ AUTO-IMPLEMENTING Issue #${issue.number}: ${issue.title}`);
              
              try {
                // Claude CodeËá™ÂãïÂÆüË£Ö„Çí„Ç∑„Éü„É•„É¨„Éº„Éà
                const branchName = `claude/issue-${issue.number}-${new Date().toISOString().slice(0,10).replace(/-/g,'')}`;
                console.log(`Creating branch: ${branchName}`);
                
                // „Éñ„É©„É≥„ÉÅ‰ΩúÊàê
                const mainRef = await github.rest.git.getRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: 'heads/main'
                });
                
                await github.rest.git.createRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `refs/heads/${branchName}`,
                  sha: mainRef.data.object.sha
                });
                
                // ÂÆüË£Ö„Éï„Ç°„Ç§„É´‰ΩúÊàêÔºàIssueÂÜÖÂÆπ„Å´Âü∫„Å•„ÅèÔºâ
                let implementationContent = '';
                let filePath = '';
                
                if (issue.title.includes('[Data]')) {
                  if (issue.title.includes('APIË™øÊüª')) {
                    filePath = 'docs/ifixit-api-research.md';
                    implementationContent = `# iFixit API Research Results

## Overview
Research results for iFixit API integration in RepairGPT.

## API Endpoints
- **Guides API**: \`/api/2.0/guides\`
- **Search API**: \`/api/2.0/search\`
- **Categories API**: \`/api/2.0/categories\`

## Authentication
- No API key required for public endpoints
- Rate limit: 100 requests per minute

## Data Format
JSON format with comprehensive repair guide data.

## Implementation Notes
Ready for integration with RepairGPT client.

---
Auto-generated by Claude Smart Automation
Issue: #${issue.number}
`;
                  } else if (issue.title.includes('JSON„Çπ„Ç≠„Éº„Éû')) {
                    filePath = 'src/schemas/repair_schema.json';
                    implementationContent = `{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "RepairGPT Repair Data Schema",
  "type": "object",
  "properties": {
    "device": {
      "type": "string",
      "description": "Device name (e.g., Nintendo Switch)"
    },
    "issue": {
      "type": "string", 
      "description": "Problem description"
    },
    "difficulty": {
      "type": "string",
      "enum": ["easy", "medium", "hard"]
    },
    "tools_required": {
      "type": "array",
      "items": {"type": "string"}
    },
    "parts_required": {
      "type": "array",
      "items": {"type": "string"}
    },
    "steps": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "step_number": {"type": "integer"},
          "description": {"type": "string"},
          "image_url": {"type": "string"}
        }
      }
    },
    "warnings": {
      "type": "array",
      "items": {"type": "string"}
    }
  },
  "required": ["device", "issue", "difficulty", "steps"]
}`;
                  } else if (issue.title.includes('API„ÇØ„É©„Ç§„Ç¢„É≥„Éà')) {
                    filePath = 'src/clients/ifixit_client.py';
                    implementationContent = `"""
iFixit API Client for RepairGPT
Auto-generated by Claude Smart Automation
"""

import requests
import json
from typing import Dict, List, Optional

class IFixitClient:
    """Client for accessing iFixit API"""
    
    BASE_URL = "https://www.ifixit.com/api/2.0"
    
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'RepairGPT/1.0'
        })
    
    def get_guide(self, guide_id: int) -> Optional[Dict]:
        """Get a specific repair guide by ID"""
        try:
            response = self.session.get(f"{self.BASE_URL}/guides/{guide_id}")
            response.raise_for_status()
            return response.json()
        except requests.RequestException as e:
            print(f"Error fetching guide {guide_id}: {e}")
            return None
    
    def search_guides(self, device_name: str) -> List[Dict]:
        """Search for guides by device name"""
        try:
            params = {'q': device_name}
            response = self.session.get(f"{self.BASE_URL}/search", params=params)
            response.raise_for_status()
            return response.json().get('results', [])
        except requests.RequestException as e:
            print(f"Error searching guides for {device_name}: {e}")
            return []

# Auto-generated by Claude Smart Automation - Issue #${issue.number}
`;
                  }
                } else if (issue.title.includes('[Chat]')) {
                  if (issue.title.includes('LLM„ÉÅ„É£„ÉÉ„Éà„Éú„ÉÉ„Éà')) {
                    filePath = 'src/chat/llm_chatbot.py';
                    implementationContent = `"""
Basic LLM Chatbot for RepairGPT
Auto-generated by Claude Smart Automation
"""

from typing import List, Dict
import openai

class RepairChatbot:
    """Basic LLM chatbot for repair assistance"""
    
    def __init__(self, api_key: str):
        self.client = openai.OpenAI(api_key=api_key)
        self.conversation_history = []
    
    def chat(self, message: str, device_context: str = "") -> str:
        """Generate response for repair question"""
        
        system_prompt = f"""You are a helpful repair assistant for electronic devices.
Device context: {device_context}
Provide clear, step-by-step repair guidance."""
        
        messages = [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": message}
        ]
        
        try:
            response = self.client.chat.completions.create(
                model="gpt-4",
                messages=messages,
                max_tokens=500,
                temperature=0.7
            )
            
            return response.choices[0].message.content
            
        except Exception as e:
            return f"Error: {e}"
    
    def reset_conversation(self):
        """Reset conversation history"""
        self.conversation_history = []

# Auto-generated by Claude Smart Automation - Issue #${issue.number}
`;
                  } else if (issue.title.includes('„Éó„É≠„É≥„Éó„Éà„ÉÜ„É≥„Éó„É¨„Éº„Éà')) {
                    filePath = 'src/prompts/repair_templates.py';
                    implementationContent = `"""
Repair Prompt Templates for RepairGPT
Auto-generated by Claude Smart Automation
"""

REPAIR_TEMPLATES = {
    "diagnostic": """
Analyze this device issue and provide diagnostic information:

Device: {device}
Symptoms: {symptoms}
User Description: {description}

Please provide:
1. Most likely causes
2. Diagnostic steps
3. Tools needed for diagnosis
4. Safety precautions
""",

    "step_by_step": """
Create a detailed repair guide for:

Device: {device}
Issue: {issue}
User Skill Level: {skill_level}

Provide:
1. Required tools and parts
2. Step-by-step instructions
3. Safety warnings
4. Troubleshooting tips
""",

    "parts_recommendation": """
Recommend replacement parts for:

Device: {device}
Problem: {problem}
Budget: {budget}

Include:
1. Part names and specifications
2. Compatibility information
3. Price estimates
4. Where to purchase
"""
}

def get_template(template_name: str) -> str:
    """Get a specific prompt template"""
    return REPAIR_TEMPLATES.get(template_name, "")

def format_template(template_name: str, **kwargs) -> str:
    """Format template with provided parameters"""
    template = get_template(template_name)
    return template.format(**kwargs)

# Auto-generated by Claude Smart Automation - Issue #${issue.number}
`;
                  }
                } else if (issue.title.includes('[UI]')) {
                  if (issue.title.includes('Streamlit')) {
                    filePath = 'src/ui/chat_app.py';
                    implementationContent = `"""
Streamlit Chat UI for RepairGPT
Auto-generated by Claude Smart Automation
"""

import streamlit as st
import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from chat.llm_chatbot import RepairChatbot

def main():
    st.set_page_config(
        page_title="RepairGPT - AI Repair Assistant",
        page_icon="üîß",
        layout="wide"
    )
    
    st.title("üîß RepairGPT - AI Repair Assistant")
    st.markdown("Get AI-powered help for fixing your electronic devices!")
    
    # Sidebar for device selection
    with st.sidebar:
        st.header("Device Information")
        device_type = st.selectbox(
            "Select Device Type",
            ["Nintendo Switch", "iPhone", "iPad", "MacBook", "Gaming PC", "Other"]
        )
        
        if device_type == "Other":
            device_type = st.text_input("Enter device name:")
    
    # Main chat interface
    if "messages" not in st.session_state:
        st.session_state.messages = []
    
    # Display chat history
    for message in st.session_state.messages:
        with st.chat_message(message["role"]):
            st.write(message["content"])
    
    # Chat input
    if prompt := st.chat_input("Describe your device issue..."):
        st.session_state.messages.append({"role": "user", "content": prompt})
        
        with st.chat_message("user"):
            st.write(prompt)
        
        with st.chat_message("assistant"):
            with st.spinner("Analyzing your issue..."):
                # TODO: Integrate with actual chatbot
                response = f"I understand you're having an issue with your {device_type}. Let me help you troubleshoot this problem: {prompt}"
                st.write(response)
                st.session_state.messages.append({"role": "assistant", "content": response})

if __name__ == "__main__":
    main()

# Auto-generated by Claude Smart Automation - Issue #${issue.number}
`;
                  } else if (issue.title.includes('ÁîªÂÉè„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ')) {
                    filePath = 'src/ui/image_upload.py';
                    implementationContent = `"""
Image Upload Component for RepairGPT
Auto-generated by Claude Smart Automation
"""

import streamlit as st
from PIL import Image
import io
import base64

def image_upload_component():
    """Streamlit component for image upload and processing"""
    
    st.header("üì∏ Upload Device Image")
    st.markdown("Upload a photo of your device or the issue for AI-powered visual diagnosis.")
    
    uploaded_file = st.file_uploader(
        "Choose an image...",
        type=['png', 'jpg', 'jpeg'],
        help="Upload a clear photo of your device or the problem area"
    )
    
    if uploaded_file is not None:
        # Display the uploaded image
        image = Image.open(uploaded_file)
        
        col1, col2 = st.columns([2, 1])
        
        with col1:
            st.image(image, caption="Uploaded Image", use_column_width=True)
        
        with col2:
            st.subheader("Image Analysis")
            
            if st.button("üîç Analyze Image", type="primary"):
                with st.spinner("Analyzing image..."):
                    # TODO: Integrate with vision AI
                    st.success("Image uploaded successfully!")
                    st.info("Visual analysis feature coming soon...")
                    
                    # Image metadata
                    st.write("**Image Info:**")
                    st.write(f"- Size: {image.size}")
                    st.write(f"- Format: {image.format}")
                    st.write(f"- Mode: {image.mode}")
            
            if st.button("üóëÔ∏è Clear Image"):
                st.experimental_rerun()
    
    return uploaded_file

def process_image_for_ai(image: Image.Image) -> str:
    """Convert image to base64 for AI processing"""
    buffered = io.BytesIO()
    image.save(buffered, format="PNG")
    img_str = base64.b64encode(buffered.getvalue()).decode()
    return img_str

# Auto-generated by Claude Smart Automation - Issue #${issue.number}
`;
                  }
                }
                
                if (filePath && implementationContent) {
                  // „Éá„Ç£„É¨„ÇØ„Éà„É™‰ΩúÊàê
                  const pathParts = filePath.split('/');
                  const dirPath = pathParts.slice(0, -1).join('/');
                  
                  if (dirPath) {
                    try {
                      await github.rest.repos.getContent({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        path: dirPath,
                        ref: branchName
                      });
                    } catch (error) {
                      // „Éá„Ç£„É¨„ÇØ„Éà„É™„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÅØ‰ΩúÊàê
                      if (error.status === 404) {
                        await github.rest.repos.createOrUpdateFileContents({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          path: `${dirPath}/.gitkeep`,
                          message: `Create directory structure for issue #${issue.number}`,
                          content: Buffer.from('').toString('base64'),
                          branch: branchName
                        });
                      }
                    }
                  }
                  
                  // „Éï„Ç°„Ç§„É´‰ΩúÊàê
                  await github.rest.repos.createOrUpdateFileContents({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    path: filePath,
                    message: `Implement ${issue.title} - Issue #${issue.number}`,
                    content: Buffer.from(implementationContent).toString('base64'),
                    branch: branchName
                  });
                  
                  console.log(`‚úÖ Created implementation file: ${filePath}`);
                  
                  // claude-processed„É©„Éô„É´„ÇíËøΩÂä†
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    labels: ['claude-processed']
                  });
                  
                  console.log(`üéØ Issue #${issue.number} AUTO-IMPLEMENTATION COMPLETED!`);
                }
                
              } catch (autoImplError) {
                console.log(`‚ùå Auto-implementation failed for Issue #${issue.number}: ${autoImplError.message}`);
                continue;
              }
            }
            
            // Phase 2: claude-processed„É©„Éô„É´„ÅÆIssue„ÇíPRÂá¶ÁêÜ
            if (processedIssues.length === 0) {
              console.log('No Claude-processed issues found for PR processing');
              return;
            }
            
            for (const issue of processedIssues) {
              console.log(`\nüîç Processing Issue #${issue.number}: ${issue.title}`);
              
              try {
                // Èñ¢ÈÄ£„Éñ„É©„É≥„ÉÅ„ÇíÊ§úÁ¥¢
                const branches = await github.rest.repos.listBranches({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  per_page: 100
                });
                
                // ÊîπËâØ„Åï„Çå„Åü„Éñ„É©„É≥„ÉÅÊ§úÁ¥¢„É≠„Ç∏„ÉÉ„ÇØ - „Çø„Ç§„É†„Çπ„Çø„É≥„Éó„Éê„Ç∞‰øÆÊ≠£
                const claudeBranches = branches.data.filter(branch => {
                  // Ê≠£Á¢∫„Å™„Éë„Çø„Éº„É≥„Éû„ÉÉ„ÉÅ„É≥„Ç∞ - „Çø„Ç§„É†„Çπ„Çø„É≥„ÉóË™§Ê§úÂá∫„ÇíÈò≤„Åê
                  const exactIssueMatch = branch.name.includes(`issue-${issue.number}`) && 
                                          (branch.name.includes(`claude`) || branch.name.includes(`issue-${issue.number}-`));
                  const claudeIssueMatch = branch.name.match(new RegExp(`claude.*issue.*${issue.number}(?![0-9])`));
                  
                  return exactIssueMatch || claudeIssueMatch;
                });
                
                console.log(`Found ${claudeBranches.length} potential branches for Issue #${issue.number}:`);
                claudeBranches.forEach(branch => console.log(`  - ${branch.name}`));
                
                if (claudeBranches.length === 0) {
                  console.log(`No Claude branch found for Issue #${issue.number}`);
                  continue;
                }
                
                // ÊúÄÊñ∞„ÅÆ„Éñ„É©„É≥„ÉÅ„ÇíÈÅ∏Êäû (Ê≠£Á¢∫„Å™issueÁï™Âè∑„Éû„ÉÉ„ÉÅ„ÇíÂÑ™ÂÖà)
                const claudeBranch = claudeBranches.sort((a, b) => {
                  // issue-{number}„ÇíÂê´„ÇÄ„Éñ„É©„É≥„ÉÅ„ÇíÂÑ™ÂÖà
                  const aHasExactIssue = a.name.includes(`issue-${issue.number}`);
                  const bHasExactIssue = b.name.includes(`issue-${issue.number}`);
                  
                  if (aHasExactIssue && !bHasExactIssue) return -1;
                  if (!aHasExactIssue && bHasExactIssue) return 1;
                  
                  // ‰∏°Êñπ„Å®„ÇÇÂêå„ÅòÊù°‰ª∂„Å™„ÇâÂêçÂâç„ÅßÈÄÜÈ†Ü„ÇΩ„Éº„Éà (Êñ∞„Åó„ÅÑ„Éñ„É©„É≥„ÉÅ„ÅåÈÄöÂ∏∏Âæå„Å´Êù•„Çã)
                  return b.name.localeCompare(a.name);
                })[0];
                
                console.log(`Selected branch: ${claudeBranch.name}`);
                
                // Êó¢Â≠òPR„Çí„ÉÅ„Çß„ÉÉ„ÇØ
                const existingPRs = await github.rest.pulls.list({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  head: `${context.repo.owner}:${claudeBranch.name}`,
                  state: 'all'
                });
                
                let prNumber = null;
                
                if (existingPRs.data.length > 0) {
                  const pr = existingPRs.data[0];
                  console.log(`Found existing PR #${pr.number}, state: ${pr.state}`);
                  
                  if (pr.state === 'open') {
                    prNumber = pr.number;
                  } else {
                    console.log(`PR #${pr.number} is already ${pr.state}`);
                    continue;
                  }
                } else {
                  // PR„Çí‰ΩúÊàê
                  console.log(`üìù Creating PR for Issue #${issue.number}`);
                  
                  try {
                    const prBody = [
                      '## üöÄ „Çπ„Éû„Éº„ÉàËá™ÂãïÂåñÂá¶ÁêÜ',
                      '',
                      '### Èñ¢ÈÄ£Issue',
                      `Closes #${issue.number}`,
                      '',
                      '### Ëá™ÂãïÂåñ„Éï„É≠„Éº',
                      '- [x] ‚úÖ Claude CodeÂÆüË£ÖÊ§úÁü•',
                      '- [x] ‚úÖ Ëá™ÂãïPR‰ΩúÊàêÔºàÂπ≥Êó•Â§úÈñì„ÉªÂúüÊó•ÊòºÈñìÔºâ',
                      '- [x] ‚úÖ Ëá™Âãï„Éû„Éº„Ç∏ÂÆüË°å',
                      '- [x] ‚úÖ IssueËá™Âãï„ÇØ„É≠„Éº„Ç∫',
                      '- [x] ‚úÖ „Éñ„É©„É≥„ÉÅËá™ÂãïÂâäÈô§',
                      '',
                      '### ÂÆüË°åÊôÇÂàª',
                      now.toISOString(),
                      '',
                      '### „Çπ„Ç±„Ç∏„É•„Éº„É´',
                      '- Âπ≥Êó•: 23:00, 02:00, 05:00 JST',
                      '- ÂúüÊó•: 10:00, 14:00, 18:00, 22:00 JST',
                      '',
                      '---',
                      'üöÄ **Smart Automation** | Generated with Claude Code Max'
                    ].join('\n');
                    
                    const pr = await github.rest.pulls.create({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      title: `fix: ${issue.title} (closes #${issue.number})`,
                      head: claudeBranch.name,
                      base: 'main',
                      body: prBody
                    });
                    
                    prNumber = pr.data.number;
                    console.log(`‚úÖ Created PR #${prNumber}`);
                    
                  } catch (prError) {
                    console.log(`‚ùå PR creation failed: ${prError.message}`);
                    continue;
                  }
                }
                
                // PR„Éû„Éº„Ç∏Âá¶ÁêÜ
                if (prNumber) {
                  console.log(`üîÑ Auto-merging PR #${prNumber}`);
                  
                  // „Éû„Éº„Ç∏Ââç„Å´Áü≠ÊôÇÈñìÂæÖÊ©ü
                  await new Promise(resolve => setTimeout(resolve, 3000));
                  
                  try {
                    await github.rest.pulls.merge({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: prNumber,
                      commit_title: `Smart Auto-merge: Issue #${issue.number}`,
                      merge_method: 'squash'
                    });
                    console.log(`‚úÖ Merged PR #${prNumber}`);
                  } catch (mergeError) {
                    console.log(`‚ö†Ô∏è Merge failed: ${mergeError.message}`);
                    continue;
                  }
                }
                
                // IssueÂÆå‰∫ÜÂá¶ÁêÜ
                console.log(`üîí Closing Issue #${issue.number}`);
                
                const commentBody = [
                  'üöÄ **„Çπ„Éû„Éº„ÉàËá™ÂãïÂåñÂá¶ÁêÜÂÆå‰∫Ü**',
                  '',
                  `Issue #${issue.number} „ÅÆ„Çπ„Éû„Éº„ÉàËá™ÂãïÂåñ„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü„ÄÇ`,
                  '',
                  '**ÂÆüË°åÂÜÖÂÆπ:**',
                  '- ü§ñ Claude CodeÂÆüË£ÖÊ§úÁü•',
                  '- üìù Ëá™ÂãïPR‰ΩúÊàê„Éª„Éû„Éº„Ç∏',
                  '- üîí IssueËá™Âãï„ÇØ„É≠„Éº„Ç∫',
                  '- üßπ „Éñ„É©„É≥„ÉÅËá™ÂãïÂâäÈô§',
                  '',
                  `**ÂÆüË°åÊôÇÂàª:** ${now.toISOString()}`,
                  '',
                  '**ÂÆüË°å„Çπ„Ç±„Ç∏„É•„Éº„É´:**',
                  '- Âπ≥Êó•: Â§úÈñìËá™ÂãïÂÆüË°åÔºà23:00, 02:00, 05:00 JSTÔºâ',
                  '- ÂúüÊó•: ÊòºÈñìËá™ÂãïÂÆüË°åÔºà10:00, 14:00, 18:00, 22:00 JSTÔºâ',
                  '',
                  '---',
                  'üöÄ **Smart Automation Success** | Generated with Claude Code Max'
                ].join('\n');
                
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: commentBody
                });
                
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  state: 'closed'
                });
                
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['claude-completed', 'smart-automation']
                });
                
                // „Éñ„É©„É≥„ÉÅÂâäÈô§
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                try {
                  await github.rest.git.deleteRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: `heads/${claudeBranch.name}`
                  });
                  console.log(`üóëÔ∏è Deleted branch ${claudeBranch.name}`);
                } catch (deleteError) {
                  console.log(`‚ö†Ô∏è Branch deletion failed: ${deleteError.message}`);
                }
                
                console.log(`üéØ Issue #${issue.number} SMART AUTOMATION COMPLETED!`);
                
              } catch (issueError) {
                console.log(`‚ùå Issue #${issue.number} processing failed: ${issueError.message}`);
                continue;
              }
            }
            
            console.log('\nüöÄ SMART AUTOMATION FINISHED');
            
          } catch (error) {
            console.log(`‚ùå Smart automation error: ${error.message}`);
            console.log(error.stack);
            throw error;
          }