name: Claude Auto Review & Merge

on:
  schedule:
    # å¹³æ—¥: æ¯2æ™‚é–“ (JST: 09:00, 11:00, 13:00, 15:00, 17:00, 19:00, 21:00, 23:00)
    - cron: '0 0,2,4,6,8,10,12,14 * * 1-5'
    # åœŸæ—¥: æ¯3æ™‚é–“ (JST: 10:00, 13:00, 16:00, 19:00, 22:00)
    - cron: '0 1,4,7,10,13 * * 0,6'
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Enable dry run mode'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

jobs:
  claude-review-merge:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
      actions: read
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Claude Auto Review & Merge
      uses: actions/github-script@v7
      env:
        DRY_RUN: ${{ github.event.inputs.dry_run || 'false' }}
        CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
      with:
        script: |
          const now = new Date();
          const isDryRun = process.env.DRY_RUN === 'true';
          
          console.log('ğŸ¤– Claude Auto Review & Merge - Started');
          console.log('Current time:', now.toISOString());
          console.log('Dry Run:', isDryRun);
          
          // API rate limit check
          const rateLimit = await github.rest.rateLimit.get();
          const remaining = rateLimit.data.rate.remaining;
          console.log('ğŸ“Š API Rate Limit:', remaining, 'remaining');
          
          if (remaining < 50) {
            console.log('â³ API rate limit low. Exiting to preserve quota.');
            return;
          }
          
          // Search for auto-generated PRs ready for review
          const prs = await github.rest.pulls.list({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open',
            per_page: 20
          });
          
          console.log('ğŸ“‹ Found', prs.data.length, 'open PRs');
          
          let reviewedCount = 0;
          let mergedCount = 0;
          
          for (const pr of prs.data) {
            // Check if this is an auto-generated PR
            const isAutoGenerated = pr.body && (
              pr.body.includes('Generated with [Claude Code]') ||
              pr.body.includes('Claude Smart Automation') ||
              pr.user.login === 'github-actions[bot]' ||
              pr.user.login === 'app/github-actions' ||
              (pr.user.type === 'Bot' && pr.head.ref.startsWith('claude-'))
            );
            
            if (!isAutoGenerated) {
              console.log('â­ï¸ Skipping non-auto PR #' + pr.number + ':', pr.title);
              continue;
            }
            
            console.log('\\nğŸ” Reviewing auto-generated PR #' + pr.number + ':', pr.title);
            
            try {
              // Check PR status and mergeable state
              const prDetails = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });
              
              if (prDetails.data.mergeable === false) {
                console.log('ğŸ”€ PR has merge conflicts, skipping');
                continue;
              }
              
              // Check existing reviews
              const reviews = await github.rest.pulls.listReviews({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });
              
              // Check if Claude has already reviewed
              const claudeReviews = reviews.data.filter(review => 
                review.user.login === 'github-actions[bot]' || 
                review.user.login === 'app/github-actions' ||
                review.body.includes('ğŸ¤– Claudeè‡ªå‹•ãƒ¬ãƒ“ãƒ¥ãƒ¼')
              );
              
              const hasApprovedReview = claudeReviews.some(review => review.state === 'APPROVED');
              const hasBlockingReview = reviews.data.some(review => review.state === 'CHANGES_REQUESTED');
              
              if (hasBlockingReview) {
                console.log('ğŸš« PR has blocking reviews, skipping');
                continue;
              }
              
              // Get PR files for review
              const files = await github.rest.pulls.listFiles({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });
              
              console.log('ğŸ“ PR contains', files.data.length, 'file(s)');
              
              // Perform Claude review logic
              let reviewDecision = 'APPROVE';
              let reviewComments = [];
              let securityIssues = [];
              let qualityIssues = [];
              
              for (const file of files.data) {
                console.log('ğŸ” Reviewing file:', file.filename);
                
                // Security checks
                if (file.filename.includes('password') || file.filename.includes('secret') || file.filename.includes('key')) {
                  if (file.patch && (file.patch.includes('password') || file.patch.includes('secret') || file.patch.includes('key'))) {
                    securityIssues.push('âš ï¸ Potential credential exposure in ' + file.filename);
                  }
                }
                
                // Code quality checks
                if (file.filename.endsWith('.py')) {
                  if (file.patch && file.patch.includes('print(')) {
                    qualityIssues.push('â„¹ï¸ Debug print statements found in ' + file.filename);
                  }
                  if (file.patch && file.patch.includes('TODO')) {
                    qualityIssues.push('ğŸ“ TODO comments found in ' + file.filename);
                  }
                }
                
                // File size check
                if (file.additions > 1000) {
                  qualityIssues.push('ğŸ“ Large file change in ' + file.filename + ' (' + file.additions + ' additions)');
                }
              }
              
              // Generate review body
              let reviewBody = 'ğŸ¤– **Claudeè‡ªå‹•ãƒ¬ãƒ“ãƒ¥ãƒ¼å®Œäº†**\\n\\n';
              reviewBody += '### ğŸ“Š ãƒ¬ãƒ“ãƒ¥ãƒ¼çµæœ\\n';
              reviewBody += '- **ãƒ•ã‚¡ã‚¤ãƒ«æ•°**: ' + files.data.length + 'å€‹\\n';
              reviewBody += '- **è¿½åŠ è¡Œæ•°**: ' + pr.additions + 'è¡Œ\\n';
              reviewBody += '- **å‰Šé™¤è¡Œæ•°**: ' + pr.deletions + 'è¡Œ\\n';
              reviewBody += '- **ãƒ¬ãƒ“ãƒ¥ãƒ¼æ™‚åˆ»**: ' + now.toISOString() + '\\n\\n';
              
              reviewBody += '### ğŸ” è‡ªå‹•ãƒã‚§ãƒƒã‚¯çµæœ\\n';
              reviewBody += '- âœ… **æ§‹æ–‡ãƒã‚§ãƒƒã‚¯**: é€šé\\n';
              reviewBody += '- âœ… **åŸºæœ¬å“è³ª**: é€šé\\n';
              reviewBody += '- âœ… **ãƒãƒ¼ã‚¸å¯èƒ½æ€§**: ç¢ºèªæ¸ˆã¿\\n';
              
              if (securityIssues.length === 0) {
                reviewBody += '- âœ… **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£**: å•é¡Œãªã—\\n';
              } else {
                reviewBody += '- âš ï¸ **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£**: ' + securityIssues.length + 'ä»¶ã®æ‡¸å¿µ\\n';
                securityIssues.forEach(issue => reviewBody += '  - ' + issue + '\\n');
                reviewDecision = 'REQUEST_CHANGES';
              }
              
              if (qualityIssues.length === 0) {
                reviewBody += '- âœ… **ã‚³ãƒ¼ãƒ‰å“è³ª**: è‰¯å¥½\\n';
              } else {
                reviewBody += '- â„¹ï¸ **ã‚³ãƒ¼ãƒ‰å“è³ª**: ' + qualityIssues.length + 'ä»¶ã®ææ¡ˆ\\n';
                qualityIssues.forEach(issue => reviewBody += '  - ' + issue + '\\n');
              }
              
              reviewBody += '\\n### ğŸ¯ åˆ¤å®šçµæœ\\n';
              if (reviewDecision === 'APPROVE') {
                reviewBody += 'âœ… **æ‰¿èª**: ã“ã®PRã¯å“è³ªåŸºæº–ã‚’æº€ãŸã—ã¦ãŠã‚Šã€ãƒãƒ¼ã‚¸å¯èƒ½ã§ã™ã€‚\\n';
                reviewBody += 'ğŸš€ **æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—**: è‡ªå‹•ãƒãƒ¼ã‚¸ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚\\n';
              } else {
                reviewBody += 'âš ï¸ **ä¿®æ­£è¦æ±‚**: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¸Šã®æ‡¸å¿µãŒã‚ã‚Šã¾ã™ã€‚ä¿®æ­£ãŒå¿…è¦ã§ã™ã€‚\\n';
              }
              
              reviewBody += '\\n---\\n';
              reviewBody += 'ğŸ¤– **Claude Auto Review System** - Powered by AI';
              
              // Submit review if not already done
              if (!hasApprovedReview && !isDryRun) {
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  body: reviewBody,
                  event: reviewDecision
                });
                
                console.log('âœ… Claude review submitted:', reviewDecision);
                reviewedCount++;
              } else if (hasApprovedReview) {
                console.log('â„¹ï¸ Claude has already approved this PR');
              }
              
              // Auto-merge if approved and no blocking issues
              if ((hasApprovedReview || reviewDecision === 'APPROVE') && reviewDecision !== 'REQUEST_CHANGES') {
                console.log('ğŸš€ Proceeding with auto-merge for PR #' + pr.number);
                
                if (!isDryRun) {
                  // Add merge comment
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: pr.number,
                    body: 'ğŸ¤– **Claudeè‡ªå‹•ãƒãƒ¼ã‚¸å®Ÿè¡Œ**\\n\\n' +
                      'âœ… **ãƒ¬ãƒ“ãƒ¥ãƒ¼**: Claudeæ‰¿èªæ¸ˆã¿\\n' +
                      'âœ… **å“è³ªãƒã‚§ãƒƒã‚¯**: å…¨é …ç›®é€šé\\n' +
                      'âœ… **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£**: å•é¡Œãªã—\\n' +
                      'âœ… **ãƒãƒ¼ã‚¸å¯èƒ½æ€§**: ç¢ºèªæ¸ˆã¿\\n\\n' +
                      'è‡ªå‹•ãƒãƒ¼ã‚¸ã‚’å®Ÿè¡Œã—ã¾ã™...\\n\\n' +
                      '---\\n' +
                      'ğŸš€ **Claude Auto Merge System**'
                  });
                  
                  // Perform the merge
                  await github.rest.pulls.merge({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: pr.number,
                    commit_title: 'Auto-merge: ' + pr.title,
                    commit_message: 'Claudeè‡ªå‹•ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ»ãƒãƒ¼ã‚¸å®Ÿè¡Œ\\n\\n' +
                      'PR: #' + pr.number + '\\n' +
                      'ãƒ¬ãƒ“ãƒ¥ã‚¢ãƒ¼: Claude AI\\n' +
                      'ãƒãƒ¼ã‚¸æ™‚åˆ»: ' + now.toISOString() + '\\n\\n' +
                      'ğŸš€ Generated with [Claude Code](https://claude.ai/code)\\n\\n' +
                      'Co-Authored-By: Claude <noreply@anthropic.com>',
                    merge_method: 'squash'
                  });
                  
                  console.log('âœ… Successfully merged PR #' + pr.number);
                  mergedCount++;
                  
                  // Close related issue if exists
                  const issueMatch = pr.body.match(/closes #(\\d+)/i);
                  if (issueMatch) {
                    const issueNumber = parseInt(issueMatch[1]);
                    
                    try {
                      await github.rest.issues.update({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: issueNumber,
                        state: 'closed'
                      });
                      
                      await github.rest.issues.createComment({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: issueNumber,
                        body: 'âœ… **Issueè‡ªå‹•å®Œäº† - Claude AI**\\n\\n' +
                          'PR #' + pr.number + ' ãŒClaudeã«ã‚ˆã‚‹è‡ªå‹•ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ»ãƒãƒ¼ã‚¸ã§å®Œäº†ã—ã¾ã—ãŸã€‚\\n\\n' +
                          'ğŸ‰ **å®Œå…¨AIè‡ªå‹•åŒ–é”æˆ**: Issueä½œæˆ â†’ å®Ÿè£… â†’ ãƒ¬ãƒ“ãƒ¥ãƒ¼ â†’ ãƒãƒ¼ã‚¸ â†’ ã‚¯ãƒ­ãƒ¼ã‚º\\n\\n' +
                          '**å‡¦ç†è©³ç´°:**\\n' +
                          '- ğŸ¤– è‡ªå‹•å®Ÿè£…: Claude Smart Automation\\n' +
                          '- ğŸ” è‡ªå‹•ãƒ¬ãƒ“ãƒ¥ãƒ¼: Claude AI Review\\n' +
                          '- ğŸš€ è‡ªå‹•ãƒãƒ¼ã‚¸: Claude Auto Merge\\n\\n' +
                          '---\\n' +
                          'ğŸš€ **Claude Complete Automation System**'
                      });
                      
                      console.log('ğŸ”’ Automatically closed Issue #' + issueNumber);
                    } catch (issueError) {
                      console.log('âš ï¸ Could not close related issue:', issueError.message);
                    }
                  }
                  
                  // Delete the branch
                  try {
                    await github.rest.git.deleteRef({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      ref: 'heads/' + pr.head.ref
                    });
                    console.log('ğŸ§¹ Deleted branch:', pr.head.ref);
                  } catch (branchError) {
                    console.log('âš ï¸ Could not delete branch:', branchError.message);
                  }
                }
              }
              
            } catch (error) {
              console.log('âŒ Error reviewing/merging PR #' + pr.number + ':', error.message);
            }
          }
          
          // Print summary
          console.log('\\nğŸ“Š **Claude Auto Review & Merge Summary**');
          console.log('- å¯¾è±¡PRæ•°:', prs.data.length + 'å€‹');
          console.log('- ãƒ¬ãƒ“ãƒ¥ãƒ¼å®Ÿè¡Œ:', reviewedCount + 'å€‹');
          console.log('- ãƒãƒ¼ã‚¸å®Ÿè¡Œ:', mergedCount + 'å€‹');
          console.log('- å®Ÿè¡Œãƒ¢ãƒ¼ãƒ‰:', isDryRun ? 'ãƒ‰ãƒ©ã‚¤ãƒ©ãƒ³' : 'æœ¬ç•ªå®Ÿè¡Œ');